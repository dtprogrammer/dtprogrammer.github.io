<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Thu, 21 Sep 2017 04:22:39 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>51. N-Queens</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/51-n-queens/</link><guid isPermaLink="false">59c33b88a7b0fe3c2805e867</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 21 Sep 2017 04:14:34 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [&amp;quot;.Q..&amp;quot;,  // Solution 1
  &amp;quot;...Q&amp;quot;,
  &amp;quot;Q...&amp;quot;,
  &amp;quot;..Q.&amp;quot;],

 [&amp;quot;..Q.&amp;quot;,  // Solution 2
  &amp;quot;Q...&amp;quot;,
  &amp;quot;...Q&amp;quot;,
  &amp;quot;.Q..&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem can be solved through backtracking just like &lt;a href="http://dtprogrammer.github.io/52-n-queens-ii/"&gt;52. N-Queens II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A general approach can be found in the &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int y) {
    if (y == n) {
        count++;
        return;
    }
    for (int x = 0; x &amp;lt; n; x++) {
        if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
        search(y+1);
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The idea here is that we place a queen in a column and then recursive call the funstion for other row with limitation on where the queen can be places.&lt;/li&gt;
&lt;li&gt;There are two diagonal placement which is not allowed and they can be calculated with the following formulae:
&lt;ul&gt;
&lt;li&gt;Diagonal 1: &lt;code&gt;col + row&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Diagonal 2: &lt;code&gt;col - row + n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In this approach we also track the queen placement so that we can return the valid board configurations.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p51/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is hard to analyze the time complexity of this algorithm.&lt;/li&gt;
&lt;li&gt;The time complexity is lower bounded by the number of non-attacking placements&lt;/li&gt;
&lt;li&gt;There is no exact formula for it in terms of &lt;code&gt;n&lt;/code&gt;. Although its known that it tends to &lt;code&gt;n!/c to the power of n&lt;/code&gt; where &lt;code&gt;c&lt;/code&gt; is approx &lt;code&gt;2.54&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In short its &lt;em&gt;exponential&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Space complexity is O (5n) and also the space taken by the stack to keep track of the board configuration being evaluated.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Its important to understand how we track diagonal in this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>52. N-Queens II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;
&lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem can be solved through backtracking.&lt;/li&gt;
&lt;li&gt;A general approach can be found in the &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int y) {
    if (y == n) {
        count++;
        return;
    }
    for&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/52-n-queens-ii/</link><guid isPermaLink="false">59c3379ca7b0fe3c2805e865</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 21 Sep 2017 04:08:32 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;
&lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem can be solved through backtracking.&lt;/li&gt;
&lt;li&gt;A general approach can be found in the &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int y) {
    if (y == n) {
        count++;
        return;
    }
    for (int x = 0; x &amp;lt; n; x++) {
        if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
        search(y+1);
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The idea here is that we place a queen in a column and then recursive call the funstion for other row with limitation on where the queen can be places.&lt;/li&gt;
&lt;li&gt;There are two diagonal placement which is not allowed and they can be calculated with the following formulae:
&lt;ul&gt;
&lt;li&gt;Diagonal 1: &lt;code&gt;col + row&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Diagonal 2: &lt;code&gt;col - row + n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p52/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is hard to analyze the time complexity of this algorithm.&lt;/li&gt;
&lt;li&gt;The time complexity is lower bounded by the number of non-attacking placements&lt;/li&gt;
&lt;li&gt;There is no exact formula for it in terms of &lt;code&gt;n&lt;/code&gt;. Although its known that it tends to &lt;code&gt;n!/c to the power of n&lt;/code&gt; where &lt;code&gt;c&lt;/code&gt; is approx &lt;code&gt;2.54&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In short its &lt;em&gt;exponential&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Space complexity is O (5n)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Its important to understand how we track diagonal in this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>47. Permutations II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,1,2] have the following unique permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same as &lt;a href="https://dtprogrammer.github.io/76-permutations/"&gt;46. Permutations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The only difference is that &lt;code&gt;nums&lt;/code&gt; array&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/47-permutations-ii/</link><guid isPermaLink="false">59c09d22a7b0fe3c2805e81a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 19 Sep 2017 04:38:15 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,1,2] have the following unique permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same as &lt;a href="https://dtprogrammer.github.io/76-permutations/"&gt;46. Permutations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The only difference is that &lt;code&gt;nums&lt;/code&gt; array can have duplicates.&lt;/li&gt;
&lt;li&gt;For example if the &lt;code&gt;nums&lt;/code&gt; array is &lt;code&gt;1, 1, 2&lt;/code&gt; this leads to issue since we will end up with &lt;code&gt;1, 1, 2&lt;/code&gt; and &lt;code&gt;1, 1, 2&lt;/code&gt; permutations twice for &lt;code&gt;1&lt;/code&gt; at index 0 and 1.&lt;/li&gt;
&lt;li&gt;We want to avoid this situation and this can be done by tracking the indexes which has be used. When we add an element in the &lt;code&gt;tempList&lt;/code&gt; we mark it in the &lt;code&gt;used&lt;/code&gt; array and when we remove it with pop we unmark it so that it take parts in next iteration.&lt;/li&gt;
&lt;li&gt;One other thing to noted here is:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; !used[i - 1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Since the numbers are already sorted and if we see a number which is same as the one before we can only use it if the number previous to it is used. This basically means that we include this to generate the permutations for the previous one but we don't generate any permutation for this on its own.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p47/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track and the space taken by the used array which is also of size O (n).&lt;br&gt;
Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We don't make recursive call after pop since we don't want to generate a subset where any of the elements in &lt;code&gt;nums&lt;/code&gt; is not a part as its in the case of combination.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>46. Permutations</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,2,3] have the following permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same domain as &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The idea&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/46-permutations/</link><guid isPermaLink="false">59bf63c2a7b0fe3c2805e818</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 18 Sep 2017 06:19:31 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,2,3] have the following permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same domain as &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The idea here is to generate all permutation through recursion.&lt;/li&gt;
&lt;li&gt;We need to keep a track of whether we have included the element in the &lt;code&gt;tempList&lt;/code&gt; or not because in case say we added &lt;code&gt;1, 2, 3&lt;/code&gt; now when recursion unwinds and 3 and 2 is removed from the stack. The for loops moves and generate a call with &lt;code&gt;tempList&lt;/code&gt; as &lt;code&gt;1, 3&lt;/code&gt; now we don't want to add 1 again.&lt;/li&gt;
&lt;li&gt;A general approach can be found in &lt;a href="https://cses.fi/book.pdf"&gt;5.2  of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search() {
    if (permutation.size() == n) {
        // process permutation
    } else {
        for (int i = 0; i &amp;lt; n; i++) {
            if (chosen[i]) continue;
            chosen[i] = true;
            permutation.push_back(i);
            search();
            chosen[i] = false;
            permutation.pop_back();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p46/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track and the space taken by the Set to keep track of all possibe unique combination seen so far which in worse case (all unique numbers) will be equal to all possible combinations.&lt;br&gt;
Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We don't make recursive call after pop since we don't want to generate a subset where any of the elements in &lt;code&gt;nums&lt;/code&gt; is not a part as its in the case of combination.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>90. Subsets II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,2], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78.&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/90-subsets-ii/</link><guid isPermaLink="false">59bf58faa7b0fe3c2805e814</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 18 Sep 2017 05:42:16 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,2], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt; with the only difference that the &lt;code&gt;nums&lt;/code&gt; array can have duplicates.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p90/Solution.java"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;We use a Set to keep track of subsets which we have seen so far and recursed on.&lt;/li&gt;
&lt;li&gt;We also sort the array. This ensures that the Set contains is always checked for for a sorted/fixed order of numbers. For example in case of &lt;code&gt;1, 4, 4&lt;/code&gt; and &lt;code&gt;4, 1, 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Also, the pop and recurse is not done outside of the contains block so that the recursion unwindws all the way through and we get all possible combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track and the space taken by the Set to keep track of all possibe unique combination seen so far which in worse case (all unique numbers) will be equal to all possible combinations.&lt;br&gt;
Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>78. Subsets</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,3], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This &lt;a href="https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning"&gt;discussion&lt;/a&gt; is very helpful in&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/78-subsets/</link><guid isPermaLink="false">59bf1302a7b0fe3c2805e810</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 18 Sep 2017 02:00:46 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,3], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This &lt;a href="https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning"&gt;discussion&lt;/a&gt; is very helpful in understanding the general pattern to solve this problem.&lt;/li&gt;
&lt;li&gt;It is very important to understand the recursive call for this solution and how the recursion unwinds.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/eKTJpwF.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p78/Solution.java"&gt;&lt;/script&gt;
&lt;p&gt;The time complexity of the above approach is hard to analyze. Another way to solve this problem which is easier to understand and analyze is below.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p78/StackBasedSolution.java"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;The general idea can can be found in &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int k) {
    if (k == n) {
        // process subset
    } else {
        search(k+1);
        subset.push_back(k);
        search(k+1);
        subset.pop_back();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track. Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>56. Merge Intervals</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/merge-intervals/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [1,3],[2,6],[8,10],[15,18],&lt;br&gt;
return [1,6],[8,10],[15,18].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is straightforward. We can only overlap two intervals of the &lt;code&gt;start time&lt;/code&gt; of the second intervals is &lt;code&gt;&amp;lt;=&lt;/code&gt; to&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/56-merge-intervals/</link><guid isPermaLink="false">59beb645a7b0fe3c2805e80a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 17:57:12 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/merge-intervals/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [1,3],[2,6],[8,10],[15,18],&lt;br&gt;
return [1,6],[8,10],[15,18].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is straightforward. We can only overlap two intervals of the &lt;code&gt;start time&lt;/code&gt; of the second intervals is &lt;code&gt;&amp;lt;=&lt;/code&gt; to the &lt;code&gt;end time&lt;/code&gt; of the first interval.&lt;/li&gt;
&lt;li&gt;We will first need to sort the intervals on basis of the start time so that we are guranteed to see the start time in increasing sequence.&lt;/li&gt;
&lt;li&gt;We also need to keep a track of the &lt;code&gt;max&lt;/code&gt; end time for the overlapping intervals seen so far. This is needed because since &lt;code&gt;end time&lt;/code&gt; is not sorted we might see them in any order but all we care is the &lt;code&gt;max&lt;/code&gt; to create the merged interval.&lt;/li&gt;
&lt;li&gt;Once we see an interval which does not overlap anymore we add our last one, reset and continue.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p56/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity to sort is O (n * log n) and then to merge is O (n) so the overall time complexity if O (n * log n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>54. Spiral Matrix</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/spiral-matrix/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should return [1,2,3,6,9,8,7,4,5].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;&lt;/div&gt;</description><link>http://localhost:2368/54-spiral-matrix/</link><guid isPermaLink="false">59be2d56a7b0fe3c2805e808</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 08:12:05 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/spiral-matrix/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should return [1,2,3,6,9,8,7,4,5].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is straight forward. We just need to keep track of the processed rows and columns so that we avoid them in spiral traversal.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p54/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (m * n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We only go right to left and/or down to up only if the there is remaing rows and remaining columns respectively.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>103. Binary Tree Zigzag Level Order Traversal</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/103-binary-tree-zigzag-level-order-traversal/</link><guid isPermaLink="false">59be25cba7b0fe3c2805e806</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 07:39:27 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its zigzag level order traversal as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [20,9],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This problem is very similar to &lt;a href="http://dtprogrammer.github.io/102-binary-tree-level-order-traversal/"&gt;102. Binary Tree Level Order Traversal&lt;/a&gt;. We just need to reverse the order while traversing down the level.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This might be achieved by inserting the items in the queue in the desired way but an easier approach is to insert them in the result list in the desired way. The below solution takes this approach.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p103/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) since in worst case we might end up with all the nodes in level and have to keep them in queue&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>102. Binary Tree Level Order Traversal</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its level order traversal as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [9,20],
  [15,7]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/102-binary-tree-level-order-traversal/</link><guid isPermaLink="false">59bdc286a7b0fe3c2805e802</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 00:36:48 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its level order traversal as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [9,20],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem is really simple. It just need a BFS traversal of the tree with a way to track when a level ends. For this we keep a counter for levelSize which tracks the number of elements at each level.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p102/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) since in worst case we might end up with all the nodes in level and have to keep them in queue&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>73. Set Matrix Zeroes</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/set-matrix-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.&lt;/p&gt;
&lt;p&gt;click to show follow up.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Did you use extra space?&lt;br&gt;
A straight forward solution using O(mn) space is probably a bad idea.&lt;br&gt;
A&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/73-set-matrix-zeroes/</link><guid isPermaLink="false">59bdb2d9a7b0fe3c2805e800</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 16 Sep 2017 23:31:21 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/set-matrix-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.&lt;/p&gt;
&lt;p&gt;click to show follow up.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Did you use extra space?&lt;br&gt;
A straight forward solution using O(mn) space is probably a bad idea.&lt;br&gt;
A simple improvement uses O(m + n) space, but still not the best solution.&lt;br&gt;
Could you devise a constant space solution?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;I was not able to solve the problem initially with constant space. I ended up looking up discussions.&lt;/p&gt;
&lt;p&gt;The idea is to use &lt;code&gt;&amp;lt;i, 0&amp;gt;&lt;/code&gt; as marker for row and &lt;code&gt;&amp;lt;0, j&amp;gt;&lt;/code&gt; as marked for column. Now &lt;code&gt;&amp;lt;0, 0&amp;gt;&lt;/code&gt; becomes special case because it's needed for marking both 0th row and 0th column. So we use it just for the row and we use another variable col0 to store column marking for 0th column.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p73/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O(m * n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is important to traverse from the bottom-right end while setting to 0 since if we travel from top-left we will set the first row 0 if there is even one zero which in turn will set everything to 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/236-lowest-common-ancestor-of-a-binary-tree/</link><guid isPermaLink="false">59bb8b12a7b0fe3c2805e7fc</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Fri, 15 Sep 2017 08:26:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem can be solved in different possible ways. EPI also has a solution for this which is pretty lengthy. The &lt;code&gt;Discuss&lt;/code&gt; section on leetcode have a very simple solution which I learned and replicated.&lt;/p&gt;
&lt;p&gt;There are two possibilities here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The nodes are in different subtree&lt;/li&gt;
&lt;li&gt;One of the nodes itself is the root.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With the above, we can write the solution below in which if the subtree contains both the nodes then the result is subtree root itself. If it contains either of the nodes then results is that node. If none of the above cause is true then it returns null.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/KyrLj5W.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p236/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O(n) since we traverse the tree to find the LCA.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;The space complexity is constant although since the algorithm uses recursion there is O(log n = h) space required on the stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;If left is null return right, if right is null return left, if both are null the root itself is returned.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>130. Surrounded Regions</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/surrounded-regions/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all 'O's into 'X's in that surrounded region.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
X X X X&lt;br&gt;
X O O X&lt;br&gt;
X X O X&lt;br&gt;
X O X X&lt;br&gt;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/130-surrounded-regions/</link><guid isPermaLink="false">59b8da5a301d231e36fc8fe7</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 07:25:54 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/surrounded-regions/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all 'O's into 'X's in that surrounded region.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
X X X X&lt;br&gt;
X O O X&lt;br&gt;
X X O X&lt;br&gt;
X O X X&lt;br&gt;
After running your function, the board should be:&lt;/p&gt;
&lt;p&gt;X X X X&lt;br&gt;
X X X X&lt;br&gt;
X X X X&lt;br&gt;
X O X X&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;I was able to think of the solution since I have seen this problem long back. The trick here is to notice is that if any of the boundary (left, right, up, down) has &lt;code&gt;O&lt;/code&gt; then that will remain &lt;code&gt;0&lt;/code&gt; as it has an open surrounding. Now this &lt;code&gt;O&lt;/code&gt; will cause other &lt;code&gt;O&lt;/code&gt; to remain &lt;code&gt;O&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So overall the idea is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For all &lt;code&gt;O&lt;/code&gt; present in boundaries and its connected &lt;code&gt;O&lt;/code&gt; mark it with some other character. Here we choose &lt;code&gt;*&lt;/code&gt; as we know for certain they will remain &lt;code&gt;O&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now everything else can marked &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Switch &lt;code&gt;*&lt;/code&gt; back to &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My initial solution was as below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public void solve(char[][] board) {
        // flip all 0 from borders to *
        if (board != null &amp;amp;&amp;amp; board.length != 0) {
            // mark from all boundaries
            // top
            markFromBorder(board, 0, 1, 0, board[0].length);
            // bottom
            markFromBorder(board, board.length - 1, board.length, 0, board[board.length - 1].length);
            // left
            markFromBorder(board, 0, board.length, 0, 1);
            // right
            markFromBorder(board, 0, board.length, board[0].length - 1, board[0].length);
            // now mark all remaining O to X
            replaceInMatrix(board, 'O', 'X');
            replaceInMatrix(board, '*', 'O');
        }
    }

    private void replaceInMatrix(char[][] board, Character charToReplace, Character replacingChar) {
        for (int i = 0; i &amp;lt; board.length; i++) {
            for (int j = 0; j &amp;lt; board[i].length; j++) {
                if (board[i][j] == charToReplace) {
                    board[i][j] = replacingChar;
                }
            }
        }
    }

    private void markFromBorder(char[][] board, int rowStart, int rowEnd, int colStart, int colEnd) {
        for (int i = rowStart; i &amp;lt; rowEnd; i++) {
            for (int j = colStart; j &amp;lt; colEnd; j++) {
                markWithNeighbors(board, i, j);
            }
        }
    }

    private void markWithNeighbors(char[][] board, int row, int col) {
        // base case
        if (row &amp;lt; 0 || row &amp;gt;= board.length || col &amp;lt; 0 || col &amp;gt;= board[row].length) {
            return;
        }
        if (board[row][col] == 'O') {
            // mark
            board[row][col] = '*';
            // handle neighbors
            markWithNeighbors(board, row + 1, col);
            markWithNeighbors(board, row - 1, col);
            markWithNeighbors(board, row, col + 1);
            markWithNeighbors(board, row, col - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this did work for most test case it failed for one of the test cases with stack overflow. Apparently, for one of the test case leetcode checks the number of the recursive call made to be under a limit. The solution is a DFS method where the max depth of recurses should be the size of matrix i.e. N. Since, my solution makes more recursive call it failed. Later, I was able to modify my solution to make less recursive call with the help of this &lt;a href="https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms/18"&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p130/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N * N)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant. Although since we are using recursive approach the solution does take some space in the recursion stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Recurse only for &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Recurse only if the range is valid&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>75. Sort Colors</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/sort-colors/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;
&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/75-sort-colors/</link><guid isPermaLink="false">59b8c5cd301d231e36fc8fe5</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 05:58:10 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/sort-colors/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;
&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You are not suppose to use the library's sort function for this problem.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
A rather straight forward solution is a two-pass algorithm using counting sort.&lt;br&gt;
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.&lt;/p&gt;
&lt;p&gt;Could you come up with an one-pass algorithm using only constant space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This is typical &lt;a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem"&gt;Dutch National Flag&lt;/a&gt; problem in which we choose a pivot and move elements smaller than the pivot towards the left and larger towards the right.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p75/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Higher index start from the last element/index of the array and moves left through decrement.&lt;/li&gt;
&lt;li&gt;When we swap an element towards higher side we don't increment equal because the number coming from higher end might be less or equal than the pivot so we need to process it still.&lt;/li&gt;
&lt;li&gt;In case of swapping an element towards lower side we move the lower and equal both since we have already processed the left end before equal index and we know for certain that the element which is being moved to current equal index is either smaller or equal to pivot.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>49. Group Anagrams</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/group-anagrams/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;
&lt;p&gt;For example, given: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;],&lt;br&gt;
Return:&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;br&gt;
[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;br&gt;
[&amp;quot;bat&amp;quot;]&lt;br&gt;
]&lt;br&gt;
Note:&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/49-group-anagrams/</link><guid isPermaLink="false">59b8a8a6301d231e36fc8fe3</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 04:02:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/group-anagrams/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;
&lt;p&gt;For example, given: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;],&lt;br&gt;
Return:&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;br&gt;
[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;br&gt;
[&amp;quot;bat&amp;quot;]&lt;br&gt;
]&lt;br&gt;
Note: All inputs will be in lower-case.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;There are multiple ways to solve this problem.&lt;/p&gt;
&lt;h4 id="sorting"&gt;Sorting:&lt;/h4&gt;
&lt;p&gt;We can sort and generate a key to store in the HashMap although sorting will take O(N * M Log (M)) time where N is the number of strings and M is the average length of a string.&lt;/p&gt;
&lt;h4 id="primenumbermultiplication"&gt;Prime number Multiplication:&lt;/h4&gt;
&lt;p&gt;Another approach to solving this will be to assign a prime number to each character from a-z and then multiple. Since the product of two or more prime numbers is always unique we can use that to index. Although this is not a good solution as for a long string it can lead to overflow.&lt;/p&gt;
&lt;h4 id="charactercount"&gt;Character Count:&lt;/h4&gt;
&lt;p&gt;I came across this solution on &lt;a href="https://leetcode.com/problems/group-anagrams/solution/"&gt;leetcode solution&lt;/a&gt; for this problem. The idea is to generate the key for indexing through character occurrence count. The solution on leetcode uses # as a separator to separate the occurrence count so that it can create a string for hashing. Although this is not required. We can hash based on array elements. See the solution below:&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p49/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N * M) where N is the number of string and M is the average size of a string.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;The space complexity is also O (N * M)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arrays.equal() can be used to compare two arrays for elements.&lt;/li&gt;
&lt;li&gt;Arrays.hashCode() can be used to generate the hashcode for array based on elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Sun, 24 Sep 2017 08:10:11 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>268. Missing Number</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/missing-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/268-missing-number/</link><guid isPermaLink="false">59c761cc018514b5e1fc0944</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 07:43:30 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/missing-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p268/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sum of first n natural number is &lt;code&gt;n (n + 1) /2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>384. Shuffle an Array</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/shuffle-an-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Shuffle a set of numbers without duplicates.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/384-shuffle-an-array/</link><guid isPermaLink="false">59c75e51018514b5e1fc0942</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 07:32:38 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/shuffle-an-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Shuffle a set of numbers without duplicates.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We use &lt;a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"&gt;Fisher-Yates Algorithm&lt;/a&gt; to shuffle&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;-- To shuffle an array a of n elements (indices 0..n-1):
for i from n−1 downto 1 do
     j ← random integer such that 0 ≤ j ≤ i
     exchange a[j] and a[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p384/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant unless we consider the space taken by the resultant shuffled array.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>152. Maximum Product Subarray</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-product-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;
&lt;p&gt;For example, given the array [2,3,-2,4],&lt;br&gt;
the contiguous subarray [2,3] has the largest product = 6.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/53-maximum-subarray/"&gt;53. Maximum Subarray&lt;/a&gt; with the only difference&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/152-maximum-product-subarray/</link><guid isPermaLink="false">59c71e5b018514b5e1fc08f6</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 02:58:34 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-product-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;
&lt;p&gt;For example, given the array [2,3,-2,4],&lt;br&gt;
the contiguous subarray [2,3] has the largest product = 6.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/53-maximum-subarray/"&gt;53. Maximum Subarray&lt;/a&gt; with the only difference that we need to calculate the max product.&lt;/li&gt;
&lt;li&gt;In this case we need to handle the negative numbers. So we also track the minimum seen so far (the largest negative value) and when we see a negative value we switch the &lt;code&gt;maEndingHere&lt;/code&gt; and &lt;code&gt;minEndingHere&lt;/code&gt; since by multiplying with the current number they will switch signs and become the other way.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p152/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Negative number handling is the special case here&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>53. Maximum Subarray</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;More&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/53-maximum-subarray/</link><guid isPermaLink="false">59c711d6018514b5e1fc08f4</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 02:05:06 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;More practice:&lt;br&gt;
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;This problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)

the paragraph below was copied from his paper (with a little modifications)

algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum
sum in the first i elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).

MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p53/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>141. Linked List Cycle</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Can you solve it without using extra space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p141/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</description><link>http://localhost:2368/141-linked-list-cycle/</link><guid isPermaLink="false">59c6f189018514b5e1fc0868</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 23:44:25 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Can you solve it without using extra space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p141/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>654. Maximum Binary Tree</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:&lt;/p&gt;
&lt;p&gt;The root is the maximum number in the array.&lt;br&gt;
The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.&lt;br&gt;
The right subtree is the&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/654-maximum-binary-tree/</link><guid isPermaLink="false">59c6dde1018514b5e1fc0866</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 22:24:26 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:&lt;/p&gt;
&lt;p&gt;The root is the maximum number in the array.&lt;br&gt;
The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.&lt;br&gt;
The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.&lt;br&gt;
Construct the maximum tree by the given array and output the root node of this tree.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;br&gt;
The size of the given array will be in the range [1,1000].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/CBwBdff.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p654/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity in average case will be &lt;code&gt;O (n log n)&lt;/code&gt;. Since the height of the tree will be &lt;code&gt;log n&lt;/code&gt; and finding maximum takes &lt;code&gt;O (n)&lt;/code&gt; time. Although, worst case we might end up with skewed tree and the height of tree will become &lt;code&gt;n&lt;/code&gt;  and the time complexity will become &lt;code&gt;O (n pow 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant besides the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>122. Best Time to Buy and Sell Stock II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times)&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/122-best-time-to-buy-and-sell-stock-ii/</link><guid isPermaLink="false">59c6cf22018514b5e1fc0864</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 21:22:40 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is very similar to &lt;a href="http://dtprogrammer.github.io/121-best-time-to-buy-and-sell-stock/"&gt;121. Best Time to Buy and Sell Stock&lt;/a&gt; with the only difference that we can buy and sell as many times as we want but can't hold more than one stock at a time.&lt;/li&gt;
&lt;li&gt;So basically we want to buy and sell as many times as we can while making a profit to obtain maximum profit. It's our greedy approach.&lt;/li&gt;
&lt;li&gt;It should be noted that buying a stock at lowest price and holding it not making transaction to sell at peak price does not yield a better result which can be seen in the graphs below.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/media/original_images/122_maxprofit_1.PNG" alt=""&gt;&lt;br&gt;
&lt;img src="https://leetcode.com/media/original_images/122_maxprofit_2.PNG" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p122/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/"&gt;Further reading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>121. Best Time to Buy and Sell Stock</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/121-best-time-to-buy-and-sell-stock/</link><guid isPermaLink="false">59c6bb04018514b5e1fc0862</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 21:07:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem can be solved by noticing that we want to optimize for maximum profit.&lt;/li&gt;
&lt;li&gt;Obtaining maximum profit depends on finding the minimum prices and then selling at highest price following after.&lt;/li&gt;
&lt;li&gt;In short, we need to find the highest peak follow by a lowest valley.&lt;/li&gt;
&lt;li&gt;The below solution keeps a track of the minimum price seen so far and also calculates the maximum profit for all values keeping track of maximum profit seen so far.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p121/Solution.java"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;The above problem can also be solved by calculating the difference between the prices and then calculating the max which can be obtained.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;prices = [7, 1, 5, 3, 6, 4]
Stock price change [- 6, 4, -2, 3, -2]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;In the above stock price difference we need to find a window which sums to max.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p121/Solution2.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>253. Meeting Rooms II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/meeting-rooms-ii"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &amp;lt; ei), find the minimum number of conference rooms required.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given [[0, 30],[5, 10],[15, 20]],
return 2.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The idea to solve this problem is simple&lt;/li&gt;
&lt;li&gt;First&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/253-meeting-rooms-ii/</link><guid isPermaLink="false">59c6a6d0018514b5e1fc085e</guid><category>leetcode</category><category>leetcode-locked</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 18:34:23 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/meeting-rooms-ii"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si &amp;lt; ei), find the minimum number of conference rooms required.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given [[0, 30],[5, 10],[15, 20]],
return 2.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The idea to solve this problem is simple&lt;/li&gt;
&lt;li&gt;First we need to sort the &lt;code&gt;Interval&lt;/code&gt; on basis of their start time so that we can traverse them in the order they start.&lt;/li&gt;
&lt;li&gt;We initialize our min heap (based on meeting end time) with the first interval and then traverse the remaining intervals to determine how many simultaneously running intervals we have.
&lt;ul&gt;
&lt;li&gt;If most early ending interval in the queue has a end time &lt;code&gt;&amp;lt;=&lt;/code&gt; current interval start time we can reuse the room. So we just update the end time with the current interval end time.&lt;/li&gt;
&lt;li&gt;Else we know that we need another room to accomodate this even so we push the current Interval on the min heap.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p253/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n log n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>134. Gas Station</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/gas-station/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are N gas stations along a circular route, where the amount of gas at station i is gas[i].&lt;/p&gt;
&lt;p&gt;You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/134-gas-station/</link><guid isPermaLink="false">59c69ab1018514b5e1fc085c</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 18:00:21 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/gas-station/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are N gas stations along a circular route, where the amount of gas at station i is gas[i].&lt;/p&gt;
&lt;p&gt;You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.&lt;/p&gt;
&lt;p&gt;Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The solution is guaranteed to be unique.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;There are two things to be noticed here:
&lt;ul&gt;
&lt;li&gt;If we cannot reach from A to E then we cannot reach to E from any stop between A and E to E. This is there reason why we do &lt;code&gt;start = i + 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A solution always exists if total gas in the circuit is greater than or equal to total distance (total cost) of circuit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p134/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>66. Plus One</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/plus-one/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.&lt;/p&gt;
&lt;p&gt;You may assume the integer do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/66-plus-one/</link><guid isPermaLink="false">59c49625018514b5e1fc0858</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Fri, 22 Sep 2017 04:50:50 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/plus-one/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.&lt;/p&gt;
&lt;p&gt;You may assume the integer do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is pretty simple. There are only the following cases possible
&lt;ul&gt;
&lt;li&gt;547&lt;/li&gt;
&lt;li&gt;549&lt;/li&gt;
&lt;li&gt;999&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p66/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n + 1)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>39. Combination Sum</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/combination-sum/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;
&lt;p&gt;The same repeated number may be chosen from C unlimited number of times.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
All numbers (including target) will be positive integers.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/39-combination-sum/</link><guid isPermaLink="false">59c358ffa7b0fe3c2805e869</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 21 Sep 2017 06:20:37 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/combination-sum/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;
&lt;p&gt;The same repeated number may be chosen from C unlimited number of times.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
All numbers (including target) will be positive integers.&lt;br&gt;
The solution set must not contain duplicate combinations.&lt;br&gt;
For example, given candidate set [2, 3, 6, 7] and target 7,&lt;br&gt;
A solution set is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [7],
  [2, 2, 3]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is just a modification of &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;All we need to do is generate all the subsets and include those whose sum is equal to &lt;code&gt;target&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p39/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track. Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The terminating condition is if &lt;code&gt;curSum &amp;gt;= 0&lt;/code&gt; or &lt;code&gt;start&lt;/code&gt; i.e. index reached end of the array.&lt;/li&gt;
&lt;li&gt;It should also be noted that when we recurse while including the element we don't do &lt;code&gt;start + 1&lt;/code&gt; since the number can be included again.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>51. N-Queens</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/51-n-queens/</link><guid isPermaLink="false">59c33b88a7b0fe3c2805e867</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 21 Sep 2017 04:14:34 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [&amp;quot;.Q..&amp;quot;,  // Solution 1
  &amp;quot;...Q&amp;quot;,
  &amp;quot;Q...&amp;quot;,
  &amp;quot;..Q.&amp;quot;],

 [&amp;quot;..Q.&amp;quot;,  // Solution 2
  &amp;quot;Q...&amp;quot;,
  &amp;quot;...Q&amp;quot;,
  &amp;quot;.Q..&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem can be solved through backtracking just like &lt;a href="http://dtprogrammer.github.io/52-n-queens-ii/"&gt;52. N-Queens II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A general approach can be found in the &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int y) {
    if (y == n) {
        count++;
        return;
    }
    for (int x = 0; x &amp;lt; n; x++) {
        if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
        search(y+1);
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The idea here is that we place a queen in a column and then recursive call the funstion for other row with limitation on where the queen can be places.&lt;/li&gt;
&lt;li&gt;There are two diagonal placement which is not allowed and they can be calculated with the following formulae:
&lt;ul&gt;
&lt;li&gt;Diagonal 1: &lt;code&gt;col + row&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Diagonal 2: &lt;code&gt;col - row + n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In this approach we also track the queen placement so that we can return the valid board configurations.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p51/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is hard to analyze the time complexity of this algorithm.&lt;/li&gt;
&lt;li&gt;The time complexity is lower bounded by the number of non-attacking placements&lt;/li&gt;
&lt;li&gt;There is no exact formula for it in terms of &lt;code&gt;n&lt;/code&gt;. Although its known that it tends to &lt;code&gt;n!/c to the power of n&lt;/code&gt; where &lt;code&gt;c&lt;/code&gt; is approx &lt;code&gt;2.54&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In short its &lt;em&gt;exponential&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Space complexity is O (5n) and also the space taken by the stack to keep track of the board configuration being evaluated.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Its important to understand how we track diagonal in this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>52. N-Queens II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;
&lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem can be solved through backtracking.&lt;/li&gt;
&lt;li&gt;A general approach can be found in the &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int y) {
    if (y == n) {
        count++;
        return;
    }
    for&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/52-n-queens-ii/</link><guid isPermaLink="false">59c3379ca7b0fe3c2805e865</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 21 Sep 2017 04:08:32 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/n-queens-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;
&lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/static/images/problemset/8-queens.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem can be solved through backtracking.&lt;/li&gt;
&lt;li&gt;A general approach can be found in the &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int y) {
    if (y == n) {
        count++;
        return;
    }
    for (int x = 0; x &amp;lt; n; x++) {
        if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
        search(y+1);
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The idea here is that we place a queen in a column and then recursive call the funstion for other row with limitation on where the queen can be places.&lt;/li&gt;
&lt;li&gt;There are two diagonal placement which is not allowed and they can be calculated with the following formulae:
&lt;ul&gt;
&lt;li&gt;Diagonal 1: &lt;code&gt;col + row&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Diagonal 2: &lt;code&gt;col - row + n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p52/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is hard to analyze the time complexity of this algorithm.&lt;/li&gt;
&lt;li&gt;The time complexity is lower bounded by the number of non-attacking placements&lt;/li&gt;
&lt;li&gt;There is no exact formula for it in terms of &lt;code&gt;n&lt;/code&gt;. Although its known that it tends to &lt;code&gt;n!/c to the power of n&lt;/code&gt; where &lt;code&gt;c&lt;/code&gt; is approx &lt;code&gt;2.54&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In short its &lt;em&gt;exponential&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Space complexity is O (5n)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Its important to understand how we track diagonal in this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>47. Permutations II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,1,2] have the following unique permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same as &lt;a href="https://dtprogrammer.github.io/76-permutations/"&gt;46. Permutations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The only difference is that &lt;code&gt;nums&lt;/code&gt; array&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/47-permutations-ii/</link><guid isPermaLink="false">59c09d22a7b0fe3c2805e81a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 19 Sep 2017 04:38:15 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,1,2] have the following unique permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same as &lt;a href="https://dtprogrammer.github.io/76-permutations/"&gt;46. Permutations&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The only difference is that &lt;code&gt;nums&lt;/code&gt; array can have duplicates.&lt;/li&gt;
&lt;li&gt;For example if the &lt;code&gt;nums&lt;/code&gt; array is &lt;code&gt;1, 1, 2&lt;/code&gt; this leads to issue since we will end up with &lt;code&gt;1, 1, 2&lt;/code&gt; and &lt;code&gt;1, 1, 2&lt;/code&gt; permutations twice for &lt;code&gt;1&lt;/code&gt; at index 0 and 1.&lt;/li&gt;
&lt;li&gt;We want to avoid this situation and this can be done by tracking the indexes which has be used. When we add an element in the &lt;code&gt;tempList&lt;/code&gt; we mark it in the &lt;code&gt;used&lt;/code&gt; array and when we remove it with pop we unmark it so that it take parts in next iteration.&lt;/li&gt;
&lt;li&gt;One other thing to noted here is:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; !used[i - 1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Since the numbers are already sorted and if we see a number which is same as the one before we can only use it if the number previous to it is used. This basically means that we include this to generate the permutations for the previous one but we don't generate any permutation for this on its own.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p47/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track and the space taken by the used array which is also of size O (n).&lt;br&gt;
Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We don't make recursive call after pop since we don't want to generate a subset where any of the elements in &lt;code&gt;nums&lt;/code&gt; is not a part as its in the case of combination.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
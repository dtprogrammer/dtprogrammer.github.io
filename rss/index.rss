<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Mon, 25 Sep 2017 03:30:30 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>189. Rotate Array</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Try to come up as many solutions as you&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/189-rotate-array/</link><guid isPermaLink="false">59c87710018514b5e1fc0952</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 03:27:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.&lt;/p&gt;
&lt;p&gt;[show hint]&lt;/p&gt;
&lt;p&gt;Hint:&lt;br&gt;
Could you do it in-place with O(1) extra space?&lt;br&gt;
Related problem: Reverse Words in a String II&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Reverse the &lt;code&gt;whole array&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reverse first &lt;code&gt;k&lt;/code&gt; elements&lt;/li&gt;
&lt;li&gt;Reverse remaining &lt;code&gt;n - k&lt;/code&gt; elements&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Remember to handle the case where k is greater than array size.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k = k % nums.length
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p189/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>198. House Robber</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/house-robber/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/198-house-robber/</link><guid isPermaLink="false">59c86d8d018514b5e1fc0950</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 02:53:49 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/house-robber/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Since the robber can rob alternate house we have set of odds and even indexes.&lt;/li&gt;
&lt;li&gt;We can solve this by dynamic programming. For any index &lt;code&gt;i&lt;/code&gt; the max profit which can be made is either the maxProfit including the money at the location &lt;code&gt;i&lt;/code&gt; with the previous sum or by not including it which is represented by&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;maxEven = Math.max(maxOdd, maxEven + nums[i]) // if i is even
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p198/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>237. Delete Node in a Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/237-delete-node-in-a-linked-list/</link><guid isPermaLink="false">59c860f9018514b5e1fc094e</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 01:52:56 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Since the problem says that the delete will never be called for the last element and all we have is pointer to the node to be deleted. We just copy over the value from the node next to it and adjust the pointer to mimic the delete.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p237/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>238. Product of Array Except Self</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/product-of-array-except-self/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;Solve it without division and in O(n).&lt;/p&gt;
&lt;p&gt;For example, given [1,2,3,4], return&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/238-product-of-array-except-self/</link><guid isPermaLink="false">59c85e30018514b5e1fc094c</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 01:41:06 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/product-of-array-except-self/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;Solve it without division and in O(n).&lt;/p&gt;
&lt;p&gt;For example, given [1,2,3,4], return [24,12,8,6].&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We make two pass and calculate and update the result&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p238/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>160. Intersection of Two Linked Lists</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/160-intersection-of-two-linked-lists/</link><guid isPermaLink="false">59c84b22018514b5e1fc094a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 00:21:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;
The linked lists must retain their original structure after the function returns.&lt;br&gt;
You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;
Your code should preferably run in O(n) time and use only O(1) memory.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem can be solved by making by using two pointers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointerA&lt;/code&gt; traverses from &lt;code&gt;headA&lt;/code&gt; and &lt;code&gt;pointerB&lt;/code&gt; traverses from &lt;code&gt;headB&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When either of them reached thee end we set them to another list.&lt;/li&gt;
&lt;li&gt;Overall they will traverse the same distance and reach and the intersection point if one exists or become &lt;code&gt;null&lt;/code&gt; at the same time in second iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p160/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O (n)&lt;/code&gt; where n is the size of larger list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>105. Construct Binary Tree from Preorder and Inorder Traversal</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume that duplicates do not exist in the tree.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/654-maximum-binary-tree/"&gt;654. Maximum Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The pattern to notice here is that the root of the subtree always comes firt&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link><guid isPermaLink="false">59c8168e018514b5e1fc0948</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 20:49:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume that duplicates do not exist in the tree.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/654-maximum-binary-tree/"&gt;654. Maximum Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The pattern to notice here is that the root of the subtree always comes firt in the preorder traversal and in middle in inorder traversal.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;In:  D B E A F C
Pre: A B D E C F
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;We take the first element in the preorder traversal find it in the inorder traversal. Now the elements to the left to it inorder traversal is the left subtree and right to it is the inorder traversal of the right subtree.&lt;/li&gt;
&lt;li&gt;The next element in the preorder traversal is the root of the left subtree (if one exists)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/wA8vSGZ.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p105/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The time complexity in average case will be &lt;code&gt;O (n log n)&lt;/code&gt;. Since the height of the tree will be &lt;code&gt;log n&lt;/code&gt; and finding the element takes &lt;code&gt;O (n)&lt;/code&gt; time. Although, worst case we might end up with skewed tree and the height of tree will become &lt;code&gt;n&lt;/code&gt;  and the time complexity will become &lt;code&gt;O (n pow 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The time complexity can be improved to &lt;code&gt;O (n)&lt;/code&gt; by first creating a &lt;code&gt;HashTable&lt;/code&gt; which maps the keys to their positions inorder traversal. Building this &lt;code&gt;HashTable&lt;/code&gt; takes &lt;code&gt;O (n)&lt;/code&gt; time although the space complexity will increase to &lt;code&gt;O (n + h)&lt;/code&gt; where n is the space taken by the hashtable and h is height of the tree (recursion stack).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant besides the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Many different trees gives the same sequence of keys in an inorder, preorder or postorder traversal.&lt;/li&gt;
&lt;li&gt;Although, if an inorder traversal and one more (preorder or postorder) traversal is given then there exists only one unique binary tree, given the nodes hold unique values.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>283. Move Zeroes</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/move-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/283-move-zeroes/</link><guid isPermaLink="false">59c7fa90018514b5e1fc0946</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 18:34:45 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/move-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must do this in-place without making a copy of the array.&lt;br&gt;
Minimize the total number of operations.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p283/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>268. Missing Number</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/missing-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/268-missing-number/</link><guid isPermaLink="false">59c761cc018514b5e1fc0944</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 07:43:30 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/missing-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p268/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sum of first n natural number is &lt;code&gt;n (n + 1) /2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>384. Shuffle an Array</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/shuffle-an-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Shuffle a set of numbers without duplicates.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/384-shuffle-an-array/</link><guid isPermaLink="false">59c75e51018514b5e1fc0942</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 07:32:38 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/shuffle-an-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Shuffle a set of numbers without duplicates.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We use &lt;a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"&gt;Fisher-Yates Algorithm&lt;/a&gt; to shuffle&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;-- To shuffle an array a of n elements (indices 0..n-1):
for i from n−1 downto 1 do
     j ← random integer such that 0 ≤ j ≤ i
     exchange a[j] and a[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p384/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant unless we consider the space taken by the resultant shuffled array.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>152. Maximum Product Subarray</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-product-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;
&lt;p&gt;For example, given the array [2,3,-2,4],&lt;br&gt;
the contiguous subarray [2,3] has the largest product = 6.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/53-maximum-subarray/"&gt;53. Maximum Subarray&lt;/a&gt; with the only difference&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/152-maximum-product-subarray/</link><guid isPermaLink="false">59c71e5b018514b5e1fc08f6</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 02:58:34 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-product-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;
&lt;p&gt;For example, given the array [2,3,-2,4],&lt;br&gt;
the contiguous subarray [2,3] has the largest product = 6.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/53-maximum-subarray/"&gt;53. Maximum Subarray&lt;/a&gt; with the only difference that we need to calculate the max product.&lt;/li&gt;
&lt;li&gt;In this case we need to handle the negative numbers. So we also track the minimum seen so far (the largest negative value) and when we see a negative value we switch the &lt;code&gt;maEndingHere&lt;/code&gt; and &lt;code&gt;minEndingHere&lt;/code&gt; since by multiplying with the current number they will switch signs and become the other way.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p152/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Negative number handling is the special case here&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>53. Maximum Subarray</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;More&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/53-maximum-subarray/</link><guid isPermaLink="false">59c711d6018514b5e1fc08f4</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 02:05:06 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-subarray/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;More practice:&lt;br&gt;
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;This problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)

the paragraph below was copied from his paper (with a little modifications)

algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum
sum in the first i elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).

MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p53/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>141. Linked List Cycle</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Can you solve it without using extra space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p141/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</description><link>http://localhost:2368/141-linked-list-cycle/</link><guid isPermaLink="false">59c6f189018514b5e1fc0868</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 23:44:25 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Can you solve it without using extra space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p141/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>654. Maximum Binary Tree</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:&lt;/p&gt;
&lt;p&gt;The root is the maximum number in the array.&lt;br&gt;
The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.&lt;br&gt;
The right subtree is the&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/654-maximum-binary-tree/</link><guid isPermaLink="false">59c6dde1018514b5e1fc0866</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 22:24:26 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximum-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:&lt;/p&gt;
&lt;p&gt;The root is the maximum number in the array.&lt;br&gt;
The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.&lt;br&gt;
The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.&lt;br&gt;
Construct the maximum tree by the given array and output the root node of this tree.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;br&gt;
The size of the given array will be in the range [1,1000].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/CBwBdff.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p654/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity in average case will be &lt;code&gt;O (n log n)&lt;/code&gt;. Since the height of the tree will be &lt;code&gt;log n&lt;/code&gt; and finding maximum takes &lt;code&gt;O (n)&lt;/code&gt; time. Although, worst case we might end up with skewed tree and the height of tree will become &lt;code&gt;n&lt;/code&gt;  and the time complexity will become &lt;code&gt;O (n pow 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant besides the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>122. Best Time to Buy and Sell Stock II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times)&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/122-best-time-to-buy-and-sell-stock-ii/</link><guid isPermaLink="false">59c6cf22018514b5e1fc0864</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 21:22:40 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is very similar to &lt;a href="http://dtprogrammer.github.io/121-best-time-to-buy-and-sell-stock/"&gt;121. Best Time to Buy and Sell Stock&lt;/a&gt; with the only difference that we can buy and sell as many times as we want but can't hold more than one stock at a time.&lt;/li&gt;
&lt;li&gt;So basically we want to buy and sell as many times as we can while making a profit to obtain maximum profit. It's our greedy approach.&lt;/li&gt;
&lt;li&gt;It should be noted that buying a stock at lowest price and holding it not making transaction to sell at peak price does not yield a better result which can be seen in the graphs below.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://leetcode.com/media/original_images/122_maxprofit_1.PNG" alt=""&gt;&lt;br&gt;
&lt;img src="https://leetcode.com/media/original_images/122_maxprofit_2.PNG" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p122/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/"&gt;Further reading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>121. Best Time to Buy and Sell Stock</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/121-best-time-to-buy-and-sell-stock/</link><guid isPermaLink="false">59c6bb04018514b5e1fc0862</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 23 Sep 2017 21:07:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem can be solved by noticing that we want to optimize for maximum profit.&lt;/li&gt;
&lt;li&gt;Obtaining maximum profit depends on finding the minimum prices and then selling at highest price following after.&lt;/li&gt;
&lt;li&gt;In short, we need to find the highest peak follow by a lowest valley.&lt;/li&gt;
&lt;li&gt;The below solution keeps a track of the minimum price seen so far and also calculates the maximum profit for all values keeping track of maximum profit seen so far.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p121/Solution.java"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;The above problem can also be solved by calculating the difference between the prices and then calculating the max which can be obtained.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;prices = [7, 1, 5, 3, 6, 4]
Stock price change [- 6, 4, -2, 3, -2]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;In the above stock price difference we need to find a window which sums to max.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p121/Solution2.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
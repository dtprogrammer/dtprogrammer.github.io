<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Fri, 13 Oct 2017 02:24:19 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>207. Course Schedule</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/207-course-schedule/</link><guid isPermaLink="false">59e0229b2a7fec25c8dc8a22</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Fri, 13 Oct 2017 02:22:48 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2, [[1,0],[0,1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.&lt;br&gt;
You may assume that there are no duplicate edges in the input prerequisites.&lt;br&gt;
click to show more hints.&lt;/p&gt;
&lt;p&gt;Hints:&lt;br&gt;
This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.&lt;br&gt;
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.&lt;br&gt;
Topological sort could also be done via BFS.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Topological Sort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p207/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (V + E)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (V)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>Check whether a given graph is Bipartite or not</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="http://www.geeksforgeeks.org/bipartite-graph/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If a graph has odd cycle length it cannot be bipartite&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/other/graph/Bipartite.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Same time complexity as BFS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O (n * n)&lt;/code&gt; for adjancency matrix &lt;code&gt;O (V + E)&lt;/code&gt; for adjancency list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</description><link>http://localhost:2368/check-whether-a-given-graph-is-bipartite-or-not/</link><guid isPermaLink="false">59ddc4d82a7fec25c8dc8a1b</guid><category>geeksforgeeks</category><category>WePay</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 11 Oct 2017 07:17:38 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="http://www.geeksforgeeks.org/bipartite-graph/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If a graph has odd cycle length it cannot be bipartite&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/other/graph/Bipartite.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Same time complexity as BFS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O (n * n)&lt;/code&gt; for adjancency matrix &lt;code&gt;O (V + E)&lt;/code&gt; for adjancency list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>CAP Theorem</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;According to CAP theorem, a distributed software system cannot simultaneously provide more than two out of three of the following guarantees (CAP):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt;: All nodes see the same data at the same time. Consistency is achieved by updating several nodes before allowing further reads.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Availability&lt;/strong&gt;: Every request gets a response&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><link>http://localhost:2368/cap-theorem/</link><guid isPermaLink="false">59db3cf6874f280ddcef2eb1</guid><category>distributed-systems</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 09 Oct 2017 09:17:21 GMT</pubDate><media:content url="http://localhost:2368/content/images/2017/10/Hx8h0.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://localhost:2368/content/images/2017/10/Hx8h0.png" alt="CAP Theorem"&gt;&lt;p&gt;According to CAP theorem, a distributed software system cannot simultaneously provide more than two out of three of the following guarantees (CAP):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt;: All nodes see the same data at the same time. Consistency is achieved by updating several nodes before allowing further reads.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Availability&lt;/strong&gt;: Every request gets a response on success/failure. Availability is achieved by replicating the data across different servers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partition tolerance&lt;/strong&gt;: System continues to work despite message loss or partial failure. A system that is partition-tolerant can sustain any amount of network failure that doesn’t result in a failure of the entire network. Data is sufficiently replicated across combinations of nodes and networks to keep the system up through intermittent outages.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://i.stack.imgur.com/Hx8h0.png" alt="CAP Theorem"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://codahale.com/you-cant-sacrifice-partition-tolerance/"&gt;Interesting Read: You Can’t Sacrifice Partition Tolerance&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;According to the above article a distributed system must require partition tolerance since to not require it the system will need to run on a network which is guranteed to never drop a message and such a network does not exist (at least as of now).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Choosing between Consistency and Availability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choosing Consistency Over Availability:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If a system chooses to provide Consistency over Availability in the presence of partitions (again, read: failures), it will preserve the guarantees of its atomic reads and writes by refusing to respond to some requests. It may decide to shut down entirely (like the clients of a single-node data store), refuse writes (like Two-Phase Commit), or only respond to reads and writes for pieces of data whose “master” node is inside the partition component (like Membase).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Choosing Availability Over Consistency:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If a system chooses to provide Availability over Consistency in the presence of partitions (all together now: failures), it will respond to all requests, potentially returning stale reads and accepting conflicting writes. These inconsistencies are often resolved via causal ordering mechanisms like vector clocks and application-specific conflict resolution procedures. (Dynamo systems usually offer both of these; Cassandra’s hard-coded Last-Writer-Wins conflict resolution being the main exception.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;But Never Both:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You cannot, however, choose both consistency and availability in a distributed system. As a thought experiment, imagine a distributed system which keeps track of a single piece of data using three nodes—AA, BB, and CC—and which claims to be both consistent and available in the face of network partitions. Misfortune strikes, and that system is partitioned into two components: {A,B}{A,B} and {C}{C}. In this state, a write request arrives at node CC to update the single piece of data.&lt;br&gt;
That node only has two options:&lt;br&gt;
Accept the write, knowing that neither AA nor BB will know about this new data until the partition heals.&lt;br&gt;
Refuse the write, knowing that the client might not be able to contact AA or BB until the partition heals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>179. Largest Number</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a list of non negative integers, arrange them such that they form the largest number.&lt;/p&gt;
&lt;p&gt;For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.&lt;/p&gt;
&lt;p&gt;Note: The result may be very large, so you need to return a string instead of an integer.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick&lt;/h3&gt;&lt;/div&gt;</description><link>http://localhost:2368/179-largest-number/</link><guid isPermaLink="false">59d5cd03a1f270a4425a9c88</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 05 Oct 2017 06:12:40 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a list of non negative integers, arrange them such that they form the largest number.&lt;/p&gt;
&lt;p&gt;For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.&lt;/p&gt;
&lt;p&gt;Note: The result may be very large, so you need to return a string instead of an integer.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sort the number as String&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p179/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>116. Populating Next Right Pointers in Each Node</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/116-populating-next-right-pointers-in-each-node/</link><guid isPermaLink="false">59d51b79a1f270a4425a9c86</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 17:41:33 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may only use constant extra space.&lt;br&gt;
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;br&gt;
For example,&lt;br&gt;
Given the following perfect binary tree,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1
       /  \
      2    3
     / \  / \
    4  5  6  7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After calling your function, the tree should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1 -&amp;gt; NULL
       /  \
      2 -&amp;gt; 3 -&amp;gt; NULL
     / \  / \
    4-&amp;gt;5-&amp;gt;6-&amp;gt;7 -&amp;gt; NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Traverse level by level&lt;/li&gt;
&lt;li&gt;Fixing the next pointer&lt;/li&gt;
&lt;li&gt;Notice that the other side subtree can be reached by curNode's next.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The idea is to generate the next pointer level by level&lt;/li&gt;
&lt;li&gt;Generating it for the child of same node is similar but we go across tree it becomes a little different.&lt;/li&gt;
&lt;li&gt;Although at that point we already have the next for the node setup which allow us to go to the other side and use it.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p116/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>150. Evaluate Reverse Polish Notation</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Evaluate the value of an arithmetic expression in Reverse Polish Notation.&lt;/p&gt;
&lt;p&gt;Valid operators are +, -, *, /. Each operand may be an integer or another expression.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  [&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9
  [&amp;quot;4&amp;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/150-evaluate-reverse-polish-notation/</link><guid isPermaLink="false">59d48839a1f270a4425a9c82</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 07:06:54 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Evaluate the value of an arithmetic expression in Reverse Polish Notation.&lt;/p&gt;
&lt;p&gt;Valid operators are +, -, *, /. Each operand may be an integer or another expression.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  [&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9
  [&amp;quot;4&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;+&amp;quot;] -&amp;gt; (4 + (13 / 5)) -&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p150/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>279. Perfect Squares</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/perfect-squares/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.&lt;/p&gt;
&lt;p&gt;For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic Programming&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sol[&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/279-perfect-squares/</link><guid isPermaLink="false">59d47bada1f270a4425a9c80</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 06:35:14 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/perfect-squares/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.&lt;/p&gt;
&lt;p&gt;For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic Programming&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sol[i] = Math.min(sol[i], sol[i - j * j] + 1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p279/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n ^ 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>206. Reverse Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/reverse-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="iterative"&gt;Iterative:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution.java"&gt;&lt;/script&gt;
&lt;h5 id="recursive"&gt;Recursive:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution2.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; for iterative &lt;code&gt;O(n)&lt;/code&gt; for recursive&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</description><link>http://localhost:2368/206-reverse-linked-list/</link><guid isPermaLink="false">59d47083a1f270a4425a9c7d</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 05:25:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/reverse-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="iterative"&gt;Iterative:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution.java"&gt;&lt;/script&gt;
&lt;h5 id="recursive"&gt;Recursive:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution2.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; for iterative &lt;code&gt;O(n)&lt;/code&gt; for recursive&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>230. Kth Smallest Element in a BST</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
What if the BST is modified (insert/delete operations) often and you need to find the kth&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/230-kth-smallest-element-in-a-bst/</link><guid isPermaLink="false">59d3293ceb9941586725f977</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 03 Oct 2017 06:09:13 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In order traversal&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p230/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>162. Find Peak Element</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-peak-element/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/162-find-peak-element/</link><guid isPermaLink="false">59d25a6deb9941586725f973</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 02 Oct 2017 15:26:47 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-peak-element/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;/p&gt;
&lt;p&gt;You may imagine that num[-1] = num[n] = -∞.&lt;/p&gt;
&lt;p&gt;For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.&lt;/p&gt;
&lt;p&gt;click to show spoilers.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your solution should be in logarithmic complexity.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Binary search&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A very good guide to solve this problem is present &lt;a href="https://leetcode.com/problems/find-peak-element/solution/"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The idea here is that we can use binary search. If &lt;code&gt;nums(i) &amp;lt; nums(i+1)&lt;/code&gt; we know that the peak exists towards the right and we can make our &lt;code&gt;low&lt;/code&gt; boundary &lt;code&gt;mid + 1&lt;/code&gt; else we make our high boundary &lt;code&gt;mid&lt;/code&gt; since the mid itself can be peak.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p162/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>328. Odd Even Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/odd-even-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/328-odd-even-linked-list/</link><guid isPermaLink="false">59d16a5beb9941586725f971</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 22:23:32 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/odd-even-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;
return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;
The first node is considered odd, the second node even and so on ...&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Odd even pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n)&lt;/code&gt; time complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p328/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>114. Flatten Binary Tree to Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, flatten it to a linked list in-place.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1
        / \
       2   5
      / \   \
     3   4   6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The flattened tree should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Postorder traversal&lt;/li&gt;
&lt;li&gt;right and then left&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="initialsolution"&gt;Initial solution:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;I was able to implement this&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/114-flatten-binary-tree-to-linked-list/</link><guid isPermaLink="false">59d03ac0eb9941586725f96d</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 00:51:45 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, flatten it to a linked list in-place.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1
        / \
       2   5
      / \   \
     3   4   6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The flattened tree should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Postorder traversal&lt;/li&gt;
&lt;li&gt;right and then left&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="initialsolution"&gt;Initial solution:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;I was able to implement this solution which passed leetcode OJ. Although, this is not efficient&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        flatten(root.left);
        flatten(root.right);
        if (root.left != null) {
            TreeNode target = root.left;
            while (target.right != null) {
                target = target.right;
            }
            target.right = root.right;
            root.right = root.left;
            root.left = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="optimalsolution"&gt;Optimal Solution:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;The optimal way to solve this is to do &lt;code&gt;postorder&lt;/code&gt; traversal visiting the right node followed by the left.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p114/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>287. Find the Duplicate Number</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-the-duplicate-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must not modify the array (assume the array is&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/287-find-the-duplicate-number/</link><guid isPermaLink="false">59d02c76eb9941586725f96c</guid><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 00:44:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-the-duplicate-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must not modify the array (assume the array is read only).&lt;br&gt;
You must use only constant, O(1) extra space.&lt;br&gt;
Your runtime complexity should be less than O(n2).&lt;br&gt;
There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Binary search on values of array&lt;/li&gt;
&lt;li&gt;Linkedlist cycle detection&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;This approach runs a binary search between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p287/Solution2.java"&gt;&lt;/script&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;This approach models the problem as linkedlist and detects cycle entry point&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p287/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (n log n)&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="approach2"&gt;Approach 2:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (1)&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="approach2"&gt;Approach 2:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (1)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>242. Valid Anagram</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/valid-anagram/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;, return true.
s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;, return false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume the string contains only lowercase&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/242-valid-anagram/</link><guid isPermaLink="false">59cfe96ceb9941586725f96a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 30 Sep 2017 19:01:12 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/valid-anagram/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;, return true.
s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;, return false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume the string contains only lowercase alphabets.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
What if the inputs contain unicode characters? How would you adapt your solution to such case?&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use an array indexed by ascii code&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We can use &lt;code&gt;HashTable&lt;/code&gt; for unicode charset&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p242/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + m)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant for ascii charset. For unicode charset we will use HashTable and complexity will become &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>227. Basic Calculator II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/basic-calculator-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
&lt;p&gt;The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.&lt;/p&gt;
&lt;p&gt;You may assume that the given expression is always valid.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;3+2*2&amp;quot; = 7
&amp;quot; 3/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/227-basic-calculator-ii/</link><guid isPermaLink="false">59cfe506eb9941586725f968</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 30 Sep 2017 18:44:12 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/basic-calculator-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
&lt;p&gt;The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.&lt;/p&gt;
&lt;p&gt;You may assume that the given expression is always valid.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;3+2*2&amp;quot; = 7
&amp;quot; 3/2 &amp;quot; = 1
&amp;quot; 3+5 / 2 &amp;quot; = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: Do not use the eval built-in library function.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use a &lt;code&gt;Stack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Do &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; first&lt;/li&gt;
&lt;li&gt;Push &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; with correct sign for the number&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p227/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; taken by stack in case if all operators are &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
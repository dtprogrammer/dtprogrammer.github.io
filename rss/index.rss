<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Sun, 22 Oct 2017 11:01:30 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>380. Insert Delete GetRandom O(1)</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Design a data structure that supports all following operations in average O(1) time.&lt;/p&gt;
&lt;p&gt;insert(val): Inserts an item val to the set if not already present.&lt;br&gt;
remove(val): Removes an item val from the set if present.&lt;br&gt;
getRandom: Returns a random element from current set of elements. Each&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/380-insert-delete-getrandom-o-1/</link><guid isPermaLink="false">59ec79e963e0d61ae8a8be02</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 22 Oct 2017 11:00:45 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Design a data structure that supports all following operations in average O(1) time.&lt;/p&gt;
&lt;p&gt;insert(val): Inserts an item val to the set if not already present.&lt;br&gt;
remove(val): Removes an item val from the set if present.&lt;br&gt;
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.&lt;br&gt;
Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use a &lt;code&gt;HashMap&lt;/code&gt; and an &lt;code&gt;ArrayList&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p380/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O(n)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>334. Increasing Triplet Subsequence</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/increasing-triplet-subsequence/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.&lt;/p&gt;
&lt;p&gt;Formally the function should:&lt;br&gt;
Return true if there exists i, j, k&lt;br&gt;
such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/334-increasing-triplet-subsequence/</link><guid isPermaLink="false">59ec72b763e0d61ae8a8bdfe</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 22 Oct 2017 10:58:24 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/increasing-triplet-subsequence/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.&lt;/p&gt;
&lt;p&gt;Formally the function should:&lt;br&gt;
Return true if there exists i, j, k&lt;br&gt;
such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else return false.&lt;br&gt;
Your algorithm should run in O(n) time complexity and O(1) space complexity.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given [1, 2, 3, 4, 5],
return true.

Given [5, 4, 3, 2, 1],
return false.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Keep two indexes &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;mid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p334/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O(n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>630. Course Schedule III</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule-iii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/630-course-schedule-iii/</link><guid isPermaLink="false">59ec227e63e0d61ae8a8bdf0</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 22 Oct 2017 10:22:59 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule-iii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.&lt;/p&gt;
&lt;p&gt;Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
Output: 3
Explanation: 
There're totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The integer 1 &amp;lt;= d, t, n &amp;lt;= 10,000.&lt;/li&gt;
&lt;li&gt;You can't take two courses simultaneously.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Greedy approach&lt;/li&gt;
&lt;li&gt;Sort the courses on &lt;code&gt;closing date&lt;/code&gt; since we want to greedly make sure we process the courses which closes first.&lt;/li&gt;
&lt;li&gt;Have a &lt;code&gt;Heap&lt;/code&gt; which keeps the courses sorted according to the duration so we can swap the longest easily.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;For details read &lt;a href="https://leetcode.com/problems/course-schedule-iii/solution/"&gt;this&lt;/a&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p630/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O(n log n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O(n)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>210. Course Schedule II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/210-course-schedule-ii/</link><guid isPermaLink="false">59ec150463e0d61ae8a8bdee</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 22 Oct 2017 04:11:42 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.&lt;/p&gt;
&lt;p&gt;There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4, [[1,0],[2,0],[3,1],[3,2]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.&lt;br&gt;
You may assume that there are no duplicate edges in the input prerequisites.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Topological Sort&lt;/li&gt;
&lt;li&gt;Store the courses in an array&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem is very similar to &lt;a href="http://localhost:2368/207-course-schedule/"&gt;207. Course Schedule&lt;/a&gt;. We just need to keep an array &lt;code&gt;order&lt;/code&gt; to store the course sequence as we process it in the queue.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p210/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (V + E)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (V)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>207. Course Schedule</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/207-course-schedule/</link><guid isPermaLink="false">59e0229b2a7fec25c8dc8a22</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Fri, 13 Oct 2017 02:22:48 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/course-schedule/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2, [[1,0],[0,1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.&lt;br&gt;
You may assume that there are no duplicate edges in the input prerequisites.&lt;br&gt;
click to show more hints.&lt;/p&gt;
&lt;p&gt;Hints:&lt;br&gt;
This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.&lt;br&gt;
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.&lt;br&gt;
Topological sort could also be done via BFS.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Topological Sort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p207/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (V + E)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (V)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>Check whether a given graph is Bipartite or not</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="http://www.geeksforgeeks.org/bipartite-graph/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If a graph has odd cycle length it cannot be bipartite&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/other/graph/Bipartite.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Same time complexity as BFS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O (n * n)&lt;/code&gt; for adjancency matrix &lt;code&gt;O (V + E)&lt;/code&gt; for adjancency list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</description><link>http://localhost:2368/check-whether-a-given-graph-is-bipartite-or-not/</link><guid isPermaLink="false">59ddc4d82a7fec25c8dc8a1b</guid><category>geeksforgeeks</category><category>WePay</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 11 Oct 2017 07:17:38 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="http://www.geeksforgeeks.org/bipartite-graph/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If a graph has odd cycle length it cannot be bipartite&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/other/graph/Bipartite.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Same time complexity as BFS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O (n * n)&lt;/code&gt; for adjancency matrix &lt;code&gt;O (V + E)&lt;/code&gt; for adjancency list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>CAP Theorem</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;According to CAP theorem, a distributed software system cannot simultaneously provide more than two out of three of the following guarantees (CAP):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt;: All nodes see the same data at the same time. Consistency is achieved by updating several nodes before allowing further reads.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Availability&lt;/strong&gt;: Every request gets a response&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><link>http://localhost:2368/cap-theorem/</link><guid isPermaLink="false">59db3cf6874f280ddcef2eb1</guid><category>distributed-systems</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 09 Oct 2017 09:17:21 GMT</pubDate><media:content url="http://localhost:2368/content/images/2017/10/Hx8h0.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://localhost:2368/content/images/2017/10/Hx8h0.png" alt="CAP Theorem"&gt;&lt;p&gt;According to CAP theorem, a distributed software system cannot simultaneously provide more than two out of three of the following guarantees (CAP):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt;: All nodes see the same data at the same time. Consistency is achieved by updating several nodes before allowing further reads.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Availability&lt;/strong&gt;: Every request gets a response on success/failure. Availability is achieved by replicating the data across different servers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partition tolerance&lt;/strong&gt;: System continues to work despite message loss or partial failure. A system that is partition-tolerant can sustain any amount of network failure that doesn’t result in a failure of the entire network. Data is sufficiently replicated across combinations of nodes and networks to keep the system up through intermittent outages.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://i.stack.imgur.com/Hx8h0.png" alt="CAP Theorem"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://codahale.com/you-cant-sacrifice-partition-tolerance/"&gt;Interesting Read: You Can’t Sacrifice Partition Tolerance&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;According to the above article a distributed system must require partition tolerance since to not require it the system will need to run on a network which is guranteed to never drop a message and such a network does not exist (at least as of now).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Choosing between Consistency and Availability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choosing Consistency Over Availability:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If a system chooses to provide Consistency over Availability in the presence of partitions (again, read: failures), it will preserve the guarantees of its atomic reads and writes by refusing to respond to some requests. It may decide to shut down entirely (like the clients of a single-node data store), refuse writes (like Two-Phase Commit), or only respond to reads and writes for pieces of data whose “master” node is inside the partition component (like Membase).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Choosing Availability Over Consistency:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If a system chooses to provide Availability over Consistency in the presence of partitions (all together now: failures), it will respond to all requests, potentially returning stale reads and accepting conflicting writes. These inconsistencies are often resolved via causal ordering mechanisms like vector clocks and application-specific conflict resolution procedures. (Dynamo systems usually offer both of these; Cassandra’s hard-coded Last-Writer-Wins conflict resolution being the main exception.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;But Never Both:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You cannot, however, choose both consistency and availability in a distributed system. As a thought experiment, imagine a distributed system which keeps track of a single piece of data using three nodes—AA, BB, and CC—and which claims to be both consistent and available in the face of network partitions. Misfortune strikes, and that system is partitioned into two components: {A,B}{A,B} and {C}{C}. In this state, a write request arrives at node CC to update the single piece of data.&lt;br&gt;
That node only has two options:&lt;br&gt;
Accept the write, knowing that neither AA nor BB will know about this new data until the partition heals.&lt;br&gt;
Refuse the write, knowing that the client might not be able to contact AA or BB until the partition heals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>179. Largest Number</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a list of non negative integers, arrange them such that they form the largest number.&lt;/p&gt;
&lt;p&gt;For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.&lt;/p&gt;
&lt;p&gt;Note: The result may be very large, so you need to return a string instead of an integer.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick&lt;/h3&gt;&lt;/div&gt;</description><link>http://localhost:2368/179-largest-number/</link><guid isPermaLink="false">59d5cd03a1f270a4425a9c88</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 05 Oct 2017 06:12:40 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a list of non negative integers, arrange them such that they form the largest number.&lt;/p&gt;
&lt;p&gt;For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.&lt;/p&gt;
&lt;p&gt;Note: The result may be very large, so you need to return a string instead of an integer.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sort the number as String&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p179/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>116. Populating Next Right Pointers in Each Node</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/116-populating-next-right-pointers-in-each-node/</link><guid isPermaLink="false">59d51b79a1f270a4425a9c86</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 17:41:33 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may only use constant extra space.&lt;br&gt;
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;br&gt;
For example,&lt;br&gt;
Given the following perfect binary tree,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1
       /  \
      2    3
     / \  / \
    4  5  6  7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After calling your function, the tree should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1 -&amp;gt; NULL
       /  \
      2 -&amp;gt; 3 -&amp;gt; NULL
     / \  / \
    4-&amp;gt;5-&amp;gt;6-&amp;gt;7 -&amp;gt; NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Traverse level by level&lt;/li&gt;
&lt;li&gt;Fixing the next pointer&lt;/li&gt;
&lt;li&gt;Notice that the other side subtree can be reached by curNode's next.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The idea is to generate the next pointer level by level&lt;/li&gt;
&lt;li&gt;Generating it for the child of same node is similar but we go across tree it becomes a little different.&lt;/li&gt;
&lt;li&gt;Although at that point we already have the next for the node setup which allow us to go to the other side and use it.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p116/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>150. Evaluate Reverse Polish Notation</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Evaluate the value of an arithmetic expression in Reverse Polish Notation.&lt;/p&gt;
&lt;p&gt;Valid operators are +, -, *, /. Each operand may be an integer or another expression.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  [&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9
  [&amp;quot;4&amp;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/150-evaluate-reverse-polish-notation/</link><guid isPermaLink="false">59d48839a1f270a4425a9c82</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 07:06:54 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Evaluate the value of an arithmetic expression in Reverse Polish Notation.&lt;/p&gt;
&lt;p&gt;Valid operators are +, -, *, /. Each operand may be an integer or another expression.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  [&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9
  [&amp;quot;4&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;+&amp;quot;] -&amp;gt; (4 + (13 / 5)) -&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p150/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>279. Perfect Squares</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/perfect-squares/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.&lt;/p&gt;
&lt;p&gt;For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic Programming&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sol[&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/279-perfect-squares/</link><guid isPermaLink="false">59d47bada1f270a4425a9c80</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 06:35:14 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/perfect-squares/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.&lt;/p&gt;
&lt;p&gt;For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic Programming&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sol[i] = Math.min(sol[i], sol[i - j * j] + 1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p279/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n ^ 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>206. Reverse Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/reverse-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="iterative"&gt;Iterative:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution.java"&gt;&lt;/script&gt;
&lt;h5 id="recursive"&gt;Recursive:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution2.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; for iterative &lt;code&gt;O(n)&lt;/code&gt; for recursive&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</description><link>http://localhost:2368/206-reverse-linked-list/</link><guid isPermaLink="false">59d47083a1f270a4425a9c7d</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 04 Oct 2017 05:25:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/reverse-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="iterative"&gt;Iterative:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution.java"&gt;&lt;/script&gt;
&lt;h5 id="recursive"&gt;Recursive:&lt;/h5&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p206/Solution2.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; for iterative &lt;code&gt;O(n)&lt;/code&gt; for recursive&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>230. Kth Smallest Element in a BST</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
What if the BST is modified (insert/delete operations) often and you need to find the kth&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/230-kth-smallest-element-in-a-bst/</link><guid isPermaLink="false">59d3293ceb9941586725f977</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 03 Oct 2017 06:09:13 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In order traversal&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p230/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>162. Find Peak Element</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-peak-element/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/162-find-peak-element/</link><guid isPermaLink="false">59d25a6deb9941586725f973</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 02 Oct 2017 15:26:47 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-peak-element/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;/p&gt;
&lt;p&gt;You may imagine that num[-1] = num[n] = -∞.&lt;/p&gt;
&lt;p&gt;For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.&lt;/p&gt;
&lt;p&gt;click to show spoilers.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your solution should be in logarithmic complexity.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Binary search&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A very good guide to solve this problem is present &lt;a href="https://leetcode.com/problems/find-peak-element/solution/"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The idea here is that we can use binary search. If &lt;code&gt;nums(i) &amp;lt; nums(i+1)&lt;/code&gt; we know that the peak exists towards the right and we can make our &lt;code&gt;low&lt;/code&gt; boundary &lt;code&gt;mid + 1&lt;/code&gt; else we make our high boundary &lt;code&gt;mid&lt;/code&gt; since the mid itself can be peak.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p162/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>328. Odd Even Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/odd-even-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/328-odd-even-linked-list/</link><guid isPermaLink="false">59d16a5beb9941586725f971</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 22:23:32 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/odd-even-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;
return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;
The first node is considered odd, the second node even and so on ...&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Odd even pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n)&lt;/code&gt; time complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p328/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
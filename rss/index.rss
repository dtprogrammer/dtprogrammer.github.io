<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Wed, 13 Sep 2017 07:44:15 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>130. Surrounded Regions</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/surrounded-regions/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all 'O's into 'X's in that surrounded region.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
X X X X&lt;br&gt;
X O O X&lt;br&gt;
X X O X&lt;br&gt;
X O X X&lt;br&gt;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/130-surrounded-regions/</link><guid isPermaLink="false">59b8da5a301d231e36fc8fe7</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 07:25:54 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/surrounded-regions/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all 'O's into 'X's in that surrounded region.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
X X X X&lt;br&gt;
X O O X&lt;br&gt;
X X O X&lt;br&gt;
X O X X&lt;br&gt;
After running your function, the board should be:&lt;/p&gt;
&lt;p&gt;X X X X&lt;br&gt;
X X X X&lt;br&gt;
X X X X&lt;br&gt;
X O X X&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;I was able to think of the solution since I have seen this problem long back. The trick here is to notice is that if any of the boundary (left, right, up, down) has &lt;code&gt;O&lt;/code&gt; then that will remain &lt;code&gt;0&lt;/code&gt; as it has an open surrounding. Now this &lt;code&gt;O&lt;/code&gt; will cause other &lt;code&gt;O&lt;/code&gt; to remain &lt;code&gt;O&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So overall the idea is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For all &lt;code&gt;O&lt;/code&gt; present in boundaries and its connected &lt;code&gt;O&lt;/code&gt; mark it with some other character. Here we choose &lt;code&gt;*&lt;/code&gt; as we know for certain they will remain &lt;code&gt;O&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now everything else can marked &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Switch &lt;code&gt;*&lt;/code&gt; back to &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My initial solution was as below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public void solve(char[][] board) {
        // flip all 0 from borders to *
        if (board != null &amp;amp;&amp;amp; board.length != 0) {
            // mark from all boundaries
            // top
            markFromBorder(board, 0, 1, 0, board[0].length);
            // bottom
            markFromBorder(board, board.length - 1, board.length, 0, board[board.length - 1].length);
            // left
            markFromBorder(board, 0, board.length, 0, 1);
            // right
            markFromBorder(board, 0, board.length, board[0].length - 1, board[0].length);
            // now mark all remaining O to X
            replaceInMatrix(board, 'O', 'X');
            replaceInMatrix(board, '*', 'O');
        }
    }

    private void replaceInMatrix(char[][] board, Character charToReplace, Character replacingChar) {
        for (int i = 0; i &amp;lt; board.length; i++) {
            for (int j = 0; j &amp;lt; board[i].length; j++) {
                if (board[i][j] == charToReplace) {
                    board[i][j] = replacingChar;
                }
            }
        }
    }

    private void markFromBorder(char[][] board, int rowStart, int rowEnd, int colStart, int colEnd) {
        for (int i = rowStart; i &amp;lt; rowEnd; i++) {
            for (int j = colStart; j &amp;lt; colEnd; j++) {
                markWithNeighbors(board, i, j);
            }
        }
    }

    private void markWithNeighbors(char[][] board, int row, int col) {
        // base case
        if (row &amp;lt; 0 || row &amp;gt;= board.length || col &amp;lt; 0 || col &amp;gt;= board[row].length) {
            return;
        }
        if (board[row][col] == 'O') {
            // mark
            board[row][col] = '*';
            // handle neighbors
            markWithNeighbors(board, row + 1, col);
            markWithNeighbors(board, row - 1, col);
            markWithNeighbors(board, row, col + 1);
            markWithNeighbors(board, row, col - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this did work for most test case it failed for one of the test cases with stack overflow. Apparently, for one of the test case leetcode checks the number of the recursive call made to be under a limit. The solution is a DFS method where the max depth of recurses should be the size of matrix i.e. N. Since, my solution makes more recursive call it failed. Later, I was able to modify my solution to make less recursive call with the help of this &lt;a href="https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms/18"&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p130/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N * N)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant. Although since we are using recursive approach the solution does take some space in the recursion stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Recurse only for &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Recurse only if the range is valid&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>75. Sort Colors</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/sort-colors/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;
&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/75-sort-colors/</link><guid isPermaLink="false">59b8c5cd301d231e36fc8fe5</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 05:58:10 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/sort-colors/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;
&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You are not suppose to use the library's sort function for this problem.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
A rather straight forward solution is a two-pass algorithm using counting sort.&lt;br&gt;
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.&lt;/p&gt;
&lt;p&gt;Could you come up with an one-pass algorithm using only constant space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This is typical &lt;a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem"&gt;Dutch National Flag&lt;/a&gt; problem in which we choose a pivot and move elements smaller than the pivot towards the left and larger towards the right.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p75/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Higher index start from the last element/index of the array and moves left through decrement.&lt;/li&gt;
&lt;li&gt;When we swap an element towards higher side we don't increment equal because the number coming from higher end might be less or equal than the pivot so we need to process it still.&lt;/li&gt;
&lt;li&gt;In case of swapping an element towards lower side we move the lower and equal both since we have already processed the left end before equal index and we know for certain that the element which is being moved to current equal index is either smaller or equal to pivot.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>49. Group Anagrams</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/group-anagrams/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;
&lt;p&gt;For example, given: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;],&lt;br&gt;
Return:&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;br&gt;
[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;br&gt;
[&amp;quot;bat&amp;quot;]&lt;br&gt;
]&lt;br&gt;
Note:&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/49-group-anagrams/</link><guid isPermaLink="false">59b8a8a6301d231e36fc8fe3</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 04:02:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/group-anagrams/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;
&lt;p&gt;For example, given: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;],&lt;br&gt;
Return:&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;br&gt;
[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;br&gt;
[&amp;quot;bat&amp;quot;]&lt;br&gt;
]&lt;br&gt;
Note: All inputs will be in lower-case.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;There are multiple ways to solve this problem.&lt;/p&gt;
&lt;h4 id="sorting"&gt;Sorting:&lt;/h4&gt;
&lt;p&gt;We can sort and generate a key to store in the HashMap although sorting will take O(N * M Log (M)) time where N is the number of strings and M is the average length of a string.&lt;/p&gt;
&lt;h4 id="primenumbermultiplication"&gt;Prime number Multiplication:&lt;/h4&gt;
&lt;p&gt;Another approach to solving this will be to assign a prime number to each character from a-z and then multiple. Since the product of two or more prime numbers is always unique we can use that to index. Although this is not a good solution as for a long string it can lead to overflow.&lt;/p&gt;
&lt;h4 id="charactercount"&gt;Character Count:&lt;/h4&gt;
&lt;p&gt;I came across this solution on &lt;a href="https://leetcode.com/problems/group-anagrams/solution/"&gt;leetcode solution&lt;/a&gt; for this problem. The idea is to generate the key for indexing through character occurrence count. The solution on leetcode uses # as a separator to separate the occurrence count so that it can create a string for hashing. Although this is not required. We can hash based on array elements. See the solution below:&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p49/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N * M) where N is the number of string and M is the average size of a string.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;The space complexity is also O (N * M)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arrays.equal() can be used to compare two arrays for elements.&lt;/li&gt;
&lt;li&gt;Arrays.hashCode() can be used to generate the hashcode for array based on elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>50. Pow(x, n)</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/powx-n/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement pow(x, n).&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem is pretty simple although the two edge case which we need to handle are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x == 0&lt;/code&gt;: Leading to 1/x become infinite&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == Integer.MIN_VALUE&lt;/code&gt;: In this case &lt;code&gt;-n&lt;/code&gt; will overflow and come back to Integer.MIN_VALUE as its basically&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><link>http://localhost:2368/50-pow-x-n/</link><guid isPermaLink="false">59b782a3301d231e36fc8fe0</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 12 Sep 2017 06:54:16 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/powx-n/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement pow(x, n).&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem is pretty simple although the two edge case which we need to handle are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x == 0&lt;/code&gt;: Leading to 1/x become infinite&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == Integer.MIN_VALUE&lt;/code&gt;: In this case &lt;code&gt;-n&lt;/code&gt; will overflow and come back to Integer.MIN_VALUE as its basically a &lt;code&gt;Integer.MAX_VALUE + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p50/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (log n) since we reduce n by 2 in every step&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-Integer.MIN_VALUE == Integer.MIN_VALUE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Double.isInfinite()&lt;/em&gt; can returns true if the given number is infinitely large in magnitude&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>48. Rotate Image</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-image/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;
&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;
&lt;p&gt;Example&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/48-rotate-image/</link><guid isPermaLink="false">59b76e0d301d231e36fc8fde</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 12 Sep 2017 05:44:35 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-image/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;
&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;Given input matrix =&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[4,5,6],&lt;br&gt;
[7,8,9]&lt;br&gt;
],&lt;/p&gt;
&lt;p&gt;rotate the input matrix in-place such that it becomes:&lt;br&gt;
[&lt;br&gt;
[7,4,1],&lt;br&gt;
[8,5,2],&lt;br&gt;
[9,6,3]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;/p&gt;
&lt;p&gt;Given input matrix =&lt;br&gt;
[&lt;br&gt;
[ 5, 1, 9,11],&lt;br&gt;
[ 2, 4, 8,10],&lt;br&gt;
[13, 3, 6, 7],&lt;br&gt;
[15,14,12,16]&lt;br&gt;
],&lt;/p&gt;
&lt;p&gt;rotate the input matrix in-place such that it becomes:&lt;br&gt;
[&lt;br&gt;
[15,13, 2, 5],&lt;br&gt;
[14, 3, 4, 1],&lt;br&gt;
[12, 6, 8, 9],&lt;br&gt;
[16, 7,10,11]&lt;br&gt;
]&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem can be solved easily if we remember a trick.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clockwise rotation: Swap up-down and then swap elements zig-zag&lt;/li&gt;
&lt;li&gt;Anticlockwise rotation: Swap left right and then swap elements zig-zag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example for the given matrix&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[4,5,6],&lt;br&gt;
[7,8,9]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;After swapping up-down we get&lt;br&gt;
[&lt;br&gt;
[7,8,9],&lt;br&gt;
[4,5,6],&lt;br&gt;
[1,2,3]&lt;br&gt;
]&lt;br&gt;
After swapping zig-zag we get&lt;br&gt;
[&lt;br&gt;
[7,4,1],&lt;br&gt;
[8,5,2],&lt;br&gt;
[9,6,3]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Swapping up-down is pretty easy and can easily be achieved by&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; matrix.length / 2; i++) {
    for (int j = 0; j &amp;lt; matrix[0].length; j++) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[matrix.length - i - 1][j];
        matrix[matrix.length - i - 1][j] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although, I had some trouble in doing zig-zag swap it required you to limit the swap. That is once we swap &lt;code&gt;matrix[0][1]&lt;/code&gt; with &lt;code&gt;matrix[1][0]&lt;/code&gt; we should not swap it again whent the value of i becomes 1 from 0. My initial approach was to limit this with a simple if check as shown below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; matrix.length; i++) {
    for (int j = 0; j &amp;lt; matrix[0].length; j++) {
        if (i &amp;lt; j) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This made my solution pass the test but it did poorly in &lt;em&gt;Accepted Solutions Runtime Distribution&lt;/em&gt;. After seeing some solutions in the &lt;em&gt;Discussion&lt;/em&gt; I found out that &lt;code&gt;j&lt;/code&gt; can start from &lt;code&gt;i+1&lt;/code&gt; since we alwasy skip swaps where &lt;code&gt;i == j&lt;/code&gt;. I thought this will improve the performance in the &lt;em&gt;Accepted Solutions Runtime Distribution&lt;/em&gt; since we are skipping one column although the time distribution was still the same.&lt;/p&gt;
&lt;p&gt;Here is my final solution&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p48/Solution.java"&gt;&lt;/script&gt;
&lt;h4 id="timecomplexity"&gt;Time complexity&lt;/h4&gt;
&lt;p&gt;The time complexity O(n * n) since we traverse the matrix.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;As mentioned earlir the trick is:
&lt;ul&gt;
&lt;li&gt;Clockwise rotation: Swap up-down and then swap elements zig-zag&lt;/li&gt;
&lt;li&gt;Anticlockwise rotation: Swap left right and then swap elements zig-zag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For zig-zag conversion &lt;code&gt;j&lt;/code&gt; should start from &lt;code&gt;i + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>28. Implement strStr()</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/implement-strstr/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem is pretty simple although I was not able to correctly solve this problem for all test cases in single attempt. The idea here is:&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/28-implement-strstr/</link><guid isPermaLink="false">59b68ab588f7011c428b15a2</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 11 Sep 2017 13:18:29 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/implement-strstr/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem is pretty simple although I was not able to correctly solve this problem for all test cases in single attempt. The idea here is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scan through the haystack for the first character of the needle&lt;/li&gt;
&lt;li&gt;As soon as the first character is found match all the remaining character in the needlle&lt;/li&gt;
&lt;li&gt;If they do then return the index where the first character of needle occurs in the haystack.&lt;/li&gt;
&lt;li&gt;If they don't then return -1&lt;/li&gt;
&lt;li&gt;Note: For empty strings &amp;quot;&amp;quot; leetcode test cases expect to return 0. This is where my initial solution was failing as I was returning -1. I tried to have some initial checks for empty string and return early although if out of two string only one is empty then you need to return -1 and not 0.&lt;/li&gt;
&lt;/ol&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p28/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;Sine we scan the whole haystack for the first character of needle and then match remaining character it is very possible that in worse case we will run in O (m * n).&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;i and j together are used to index the haystack.&lt;/li&gt;
&lt;li&gt;The time complexity can be improved to O(m) where m is the size of haystack by using some intuitve algorithms like Rabin-Karp or KMP algorithms.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>20. Valid Parentheses</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/valid-parentheses/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;The brackets must close in the correct order, &amp;quot;()&amp;quot; and &amp;quot;()[]{}&amp;quot; are all valid but &amp;quot;(]&amp;quot; and &amp;quot;([)]&amp;quot;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/20-valid-parentheses/</link><guid isPermaLink="false">59b58772f23bc812fffcdbc1</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 10 Sep 2017 18:46:33 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/valid-parentheses/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;The brackets must close in the correct order, &amp;quot;()&amp;quot; and &amp;quot;()[]{}&amp;quot; are all valid but &amp;quot;(]&amp;quot; and &amp;quot;([)]&amp;quot; are not.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p20/Solution.java"&gt;&lt;/script&gt;&lt;/div&gt;</content:encoded></item></channel></rss>
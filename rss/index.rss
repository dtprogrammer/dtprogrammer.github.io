<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Wed, 27 Sep 2017 08:34:57 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Hadoop The Definitive Guide</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h1 id="booksummary"&gt;Book Summary&lt;/h1&gt;
&lt;p&gt;This is a summary and notes from Hadoop The Definitive Guide 4th Edition.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;more data usually beats better algorithms&lt;/li&gt;
&lt;li&gt;In a nutshell, this is what Hadoop provides: a reliable, scalable platform for storage and analysis.&lt;/li&gt;
&lt;li&gt;MapReduce is a batch query processor, and the ability to run an&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/hadoop-the-definitive-guide/</link><guid isPermaLink="false">59cb5b4fa588803d1e4d5b96</guid><category>distributed-systems</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 08:17:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h1 id="booksummary"&gt;Book Summary&lt;/h1&gt;
&lt;p&gt;This is a summary and notes from Hadoop The Definitive Guide 4th Edition.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;more data usually beats better algorithms&lt;/li&gt;
&lt;li&gt;In a nutshell, this is what Hadoop provides: a reliable, scalable platform for storage and analysis.&lt;/li&gt;
&lt;li&gt;MapReduce is a batch query processor, and the ability to run an ad hoc query against your whole dataset and get the results in a reasonable time is transformative.&lt;/li&gt;
&lt;li&gt;seek time is improving more slowly than transfer rate.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chapter2mapreduce3"&gt;Chapter 2: MapReduce3&lt;/h2&gt;
&lt;h3 id="dataflow"&gt;Data Flow&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;MapReduce job&lt;/code&gt; is a unit of work that the client wants to be performed: it consists of the input data, the MapReduce program, and configuration information.&lt;/li&gt;
&lt;li&gt;Hadoop runs the job by dividing it into tasks, of which there are two types: &lt;code&gt;map tasks&lt;/code&gt; and &lt;code&gt;reduce tasks&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The tasks are scheduled using YARN and run on nodes in the cluster. If a task fails, it will be automatically rescheduled to run on a different node.&lt;/li&gt;
&lt;li&gt;Hadoop divides the input to a MapReduce job into fixed-size pieces called &lt;code&gt;input splits&lt;/code&gt;, or just splits.&lt;/li&gt;
&lt;li&gt;Hadoop creates one map task for each split, which runs the user-defined map function for each record in the split.&lt;/li&gt;
&lt;li&gt;Having many splits means the time taken to process each split is small compared to the time to process the whole input.&lt;/li&gt;
&lt;li&gt;On the other hand, if splits are too small, the overhead of managing the splits and map task creation begins to dominate the total job execution time.&lt;/li&gt;
&lt;li&gt;For most jobs, a good split size tends to be the size of an &lt;code&gt;HDFS block&lt;/code&gt;, which is 128 MB by default.&lt;/li&gt;
&lt;li&gt;Hadoop does its best to run the map task on a node where the input data resides in HDFS, because it doesn’t use valuable cluster bandwidth. This is called the &lt;code&gt;data locality optimization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map tasks write their output to the &lt;code&gt;local disk&lt;/code&gt;, not to HDFS. Why is this? Map output is intermediate output: it’s processed by reduce tasks to produce the final output, and once the job is complete, the map output can be thrown away. So, storing it in HDFS with replication would be overkill.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/KSeXaal.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reduce tasks don’t have the advantage of data locality&lt;/code&gt;; the input to a single reduce task is normally the output from all mappers. In the present example, we have a single reduce task that is fed by all of the map tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/HFucObH.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When there are multiple reducers, the map tasks partition their output, each creating one partition for each reduce task. There can be many keys (and their associated values) in each partition, but the records for any given key are all in a single partition.&lt;/li&gt;
&lt;li&gt;The above diagram makes it clear why the data flow between map and reduce tasks is collo‐ quially known as “the shuffle,” as each reduce task is fed by many map tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="combinerfunctions"&gt;Combiner Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Many MapReduce jobs are limited by the bandwidth available on the cluster, so it pays to minimize the data transferred between map and reduce tasks. Hadoop allows the user to specify a combiner function to be run on the map output, and the combiner function’s output forms the input to the reduce function.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chapter3thehadoopdistributedfilesystem"&gt;Chapter 3: The Hadoop Distributed Filesystem&lt;/h2&gt;
&lt;/div&gt;</content:encoded></item><item><title>221. Maximal Square</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximal-square/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.&lt;/p&gt;
&lt;p&gt;For example, given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return 4.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/221-maximal-square/</link><guid isPermaLink="false">59cb5757a588803d1e4d5b94</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 07:52:23 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximal-square/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.&lt;/p&gt;
&lt;p&gt;For example, given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return 4.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;br&gt;
&lt;img src="https://i.imgur.com/8gHUcnd.png" alt=""&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/meiI5ic.png" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p221/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (m * n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>300. Longest Increasing Subsequence</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/longest-increasing-subsequence/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [10, 9, 2, 5, 3, 7, 101, 18],&lt;br&gt;
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/300-longest-increasing-subsequence/</link><guid isPermaLink="false">59cb1ee2a588803d1e4d5b8f</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 03:52:04 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/longest-increasing-subsequence/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [10, 9, 2, 5, 3, 7, 101, 18],&lt;br&gt;
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.&lt;/p&gt;
&lt;p&gt;Your algorithm should run in O(n2) complexity.&lt;/p&gt;
&lt;p&gt;Follow up: Could you improve it to O(n log n) time complexity?&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;If the current element is greater then update&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;To calculate a value of length(k), we should find a position i &amp;lt; k for which array[i] &amp;lt; array[k] and length(i) is as large as possible. Then we know that length(k) = length(i) + 1, because this is an optimal way to add array[k] to a subsequence. However, if there is no such position i, then length(k) = 1&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p300/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n ^ 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>518. Coin Change 2</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change-2/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.&lt;/p&gt;
&lt;p&gt;Note: You can assume that&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= amount &amp;lt;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/518-coin-change-2/</link><guid isPermaLink="false">59cb0af0a588803d1e4d5b89</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 02:58:25 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change-2/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.&lt;/p&gt;
&lt;p&gt;Note: You can assume that&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= amount &amp;lt;= 5000&lt;br&gt;
1 &amp;lt;= coin &amp;lt;= 5000&lt;br&gt;
the number of coins is less than 500&lt;br&gt;
the answer is guaranteed to fit into signed 32-bit integer&lt;br&gt;
Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: amount = 10, coins = [10] 
Output: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;amount - all coin value&lt;/li&gt;
&lt;li&gt;Dynamic programming&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[0] = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;iterate through coins first&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is very similar to &lt;a href="https://dtprogrammer.github.io/322-coin-change/"&gt;322. Coin Change&lt;/a&gt;. All we need to do here is keep a count rather than tracking minimum.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/hwS4hF2.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p518/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (k * n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the amount and &lt;code&gt;k&lt;/code&gt; is the number of coins denominations.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + 1)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>322. Coin Change</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/322-coin-change/</link><guid isPermaLink="false">59ca09e4a588803d1e4d5a77</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 08:06:21 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
coins = [1, 2, 5], amount = 11&lt;br&gt;
return 3 (11 = 5 + 5 + 1)&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
coins = [2], amount = 3&lt;br&gt;
return -1.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume that you have an infinite number of each kind of coin.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;amount - all coin value&lt;/li&gt;
&lt;li&gt;Dynamic programming&lt;/li&gt;
&lt;li&gt;initially min is -1 and then do the calculation&lt;/li&gt;
&lt;li&gt;min of all the  possible ways&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;value[0] = 0;
for (int x = 1; x &amp;lt;= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
       if (x-c &amp;gt;= 0) {
           value[x] = min(value[x], value[x-c]+1);
           } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p322/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n * k)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the amount and &lt;code&gt;k&lt;/code&gt; is the number of coins denominations.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + 1)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>Dynamic Programming</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic programming is a technique that combines the correctness of com- plete search and the efficiency of greedy algorithms.&lt;/li&gt;
&lt;li&gt;Dynamic programming can be applied if the problem can be divided into overlapping subproblems that can be solved independently.&lt;/li&gt;
&lt;li&gt;There are two uses for dynamic programming:
&lt;ul&gt;
&lt;li&gt;Finding an optimal solution:&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/dynamic-programming/</link><guid isPermaLink="false">59c9f9e2a588803d1e4d5a74</guid><category>Algorithms</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 07:21:13 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic programming is a technique that combines the correctness of com- plete search and the efficiency of greedy algorithms.&lt;/li&gt;
&lt;li&gt;Dynamic programming can be applied if the problem can be divided into overlapping subproblems that can be solved independently.&lt;/li&gt;
&lt;li&gt;There are two uses for dynamic programming:
&lt;ul&gt;
&lt;li&gt;Finding an optimal solution: We want to find a solution that is as large as possible or as small as possible.&lt;/li&gt;
&lt;li&gt;Counting the number of solutions: We want to calculate the total num- ber of possible solutions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dynamic programming algorithm is efficient because it uses memoization and calculates the answer to each subproblem only once.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="problems"&gt;Problems&lt;/h2&gt;
&lt;h3 id="coinproblem"&gt;Coin Problem&lt;/h3&gt;
&lt;p&gt;If types of coins = {1, 3, 4}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solve(x) = min(solve(x - 1) + 1, solve(x - 3) + 1, solve(x - 4) + 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/x2m4Mh0.png" alt=""&gt;&lt;/p&gt;
&lt;h4 id="recursivesolution"&gt;Recursive Solution&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;int solve(int x) {
    if (x &amp;lt; 0) return INF;
    if (x == 0) return 0;
    if (ready[x]) return value[x];
    int best = INF;
    for (auto c : coins) {
       best = min(best, solve(x-c)+1);
    }
    value[x] = best;
    ready[x] = true;
    return best;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where ready[x] indicates whether the value of solve(x) has been calculated, and if it is, value[x] contains this value.&lt;/p&gt;
&lt;h4 id="iterativesolution"&gt;Iterative Solution&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;value[0] = 0;
for (int x = 1; x &amp;lt;= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
       if (x-c &amp;gt;= 0) {
           value[x] = min(value[x], value[x-c]+1);
           } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The time complexity of the algorithm is &lt;code&gt;O(nk)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the target sum and &lt;code&gt;k&lt;/code&gt; is the number of coins.&lt;/p&gt;
&lt;p&gt;In the coin problem, for example, we can declare another array that indicates for each sum of money the first coin in an optimal solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value[0] = 0;
for (int x = 1; x &amp;lt;= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
       if (x-c &amp;gt;= 0 &amp;amp;&amp;amp; value[x-c]+1 &amp;lt; value[x]) {
           value[x] = value[x-c]+1;
           first[x] = c;
           } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="printingsolution"&gt;Printing Solution&lt;/h4&gt;
&lt;p&gt;After this, the following code can be used to print the coins that appear in an optimal solution for the sum n:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (n &amp;gt; 0) {
    cout &amp;lt;&amp;lt; first[n] &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    n -= first[n];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="countingsolution"&gt;Counting Solution&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;solve(x) =solve(x - 1) + solve(x - 3) + solve(x - 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/OMzPKkV.png" alt=""&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count[0] = 1;
for (int x = 1; x &amp;lt;= n; i++) {
    for (auto c : coins) {
       if (x-c &amp;gt;= 0) {
           count[x] += count[x-c];
       }
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="longestincreasingsubsequence"&gt;Longest Increasing Subsequence&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This is a maximum-length sequence of array elements that goes from left to right, and each element in the sequence is larger than the previous element.&lt;/li&gt;
&lt;li&gt;To calculate a value of length(k), we should find a position i &amp;lt; k for which array[i] &amp;lt; array[k] and length(i) is as large as possible. Then we know that length(k) = length(i) + 1, because this is an optimal way to add array[k] to a subsequence. However, if there is no such position i, then length(k) = 1, which means that the subsequence only contains array[k].&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for (int k = 0; k &amp;lt; n; k++) {
    length[k] = 1;
    for (int i = 0; i &amp;lt; k; i++) {
       if (array[i] &amp;lt; array[k]) {
           length[k] = max(length[k],length[i]+1);
       }
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content:encoded></item><item><title>139. Word Break</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/word-break/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.&lt;/p&gt;
&lt;p&gt;For example, given&lt;br&gt;
s = &amp;quot;leetcode&amp;quot;,&lt;br&gt;
dict&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/139-word-break/</link><guid isPermaLink="false">59c9f537a588803d1e4d5a72</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 06:48:59 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/word-break/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.&lt;/p&gt;
&lt;p&gt;For example, given&lt;br&gt;
s = &amp;quot;leetcode&amp;quot;,&lt;br&gt;
dict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;].&lt;/p&gt;
&lt;p&gt;Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.&lt;/p&gt;
&lt;p&gt;UPDATE (2017/1/4):&lt;br&gt;
The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;keep a boolean array to track till which position the word is valid when broken&lt;/li&gt;
&lt;li&gt;array[0] is always valid since its empty&lt;/li&gt;
&lt;li&gt;Break the string and update the boolean array&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p139/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n pow 2)&lt;/code&gt; where n is the dictionary size. This is because the lookup in the dictionary takes &lt;code&gt;O (n)&lt;/code&gt; time.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>347. Top K Frequent Elements</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/top-k-frequent-elements/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [1,1,1,2,2,3] and k = 2, return [1,2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.&lt;br&gt;
Your algorithm's time complexity must be better than&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/347-top-k-frequent-elements/</link><guid isPermaLink="false">59c9e669a588803d1e4d5a70</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 05:41:39 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/top-k-frequent-elements/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [1,1,1,2,2,3] and k = 2, return [1,2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.&lt;br&gt;
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt; of occurrence&lt;/li&gt;
&lt;li&gt;Bucket sort&lt;/li&gt;
&lt;li&gt;Return k (from end) from bucket array&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The solution involved doing the following
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;Map&amp;lt;Number, OccurrenceCount&amp;gt;&lt;/code&gt; to track how many times a number has occurred.&lt;/li&gt;
&lt;li&gt;Now iterate through the above &lt;code&gt;Map&lt;/code&gt; and put the numbers as a list in an array which is indexed by the occurrence count.&lt;/li&gt;
&lt;li&gt;Now iterate the occurence count arrya &lt;code&gt;List&amp;lt;Integer&amp;gt;[]&lt;/code&gt; in reverse order and get the k most occuring numbers.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p347/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>189. Rotate Array</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Try to come up as many solutions as you&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/189-rotate-array/</link><guid isPermaLink="false">59c87710018514b5e1fc0952</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 03:27:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-array/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.&lt;/p&gt;
&lt;p&gt;[show hint]&lt;/p&gt;
&lt;p&gt;Hint:&lt;br&gt;
Could you do it in-place with O(1) extra space?&lt;br&gt;
Related problem: Reverse Words in a String II&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Reverse the &lt;code&gt;whole array&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reverse first &lt;code&gt;k&lt;/code&gt; elements&lt;/li&gt;
&lt;li&gt;Reverse remaining &lt;code&gt;n - k&lt;/code&gt; elements&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Remember to handle the case where k is greater than array size.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k = k % nums.length
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p189/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>198. House Robber</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/house-robber/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/198-house-robber/</link><guid isPermaLink="false">59c86d8d018514b5e1fc0950</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 02:53:49 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/house-robber/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Since the robber can rob alternate house we have set of odds and even indexes.&lt;/li&gt;
&lt;li&gt;We can solve this by dynamic programming. For any index &lt;code&gt;i&lt;/code&gt; the max profit which can be made is either the maxProfit including the money at the location &lt;code&gt;i&lt;/code&gt; with the previous sum or by not including it which is represented by&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;maxEven = Math.max(maxOdd, maxEven + nums[i]) // if i is even
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p198/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>237. Delete Node in a Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/237-delete-node-in-a-linked-list/</link><guid isPermaLink="false">59c860f9018514b5e1fc094e</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 01:52:56 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Since the problem says that the delete will never be called for the last element and all we have is pointer to the node to be deleted. We just copy over the value from the node next to it and adjust the pointer to mimic the delete.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p237/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>238. Product of Array Except Self</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/product-of-array-except-self/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;Solve it without division and in O(n).&lt;/p&gt;
&lt;p&gt;For example, given [1,2,3,4], return&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/238-product-of-array-except-self/</link><guid isPermaLink="false">59c85e30018514b5e1fc094c</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 01:41:06 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/product-of-array-except-self/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;Solve it without division and in O(n).&lt;/p&gt;
&lt;p&gt;For example, given [1,2,3,4], return [24,12,8,6].&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We make two pass and calculate and update the result&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p238/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>160. Intersection of Two Linked Lists</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/160-intersection-of-two-linked-lists/</link><guid isPermaLink="false">59c84b22018514b5e1fc094a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 25 Sep 2017 00:21:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;
The linked lists must retain their original structure after the function returns.&lt;br&gt;
You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;
Your code should preferably run in O(n) time and use only O(1) memory.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem can be solved by making by using two pointers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointerA&lt;/code&gt; traverses from &lt;code&gt;headA&lt;/code&gt; and &lt;code&gt;pointerB&lt;/code&gt; traverses from &lt;code&gt;headB&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When either of them reached thee end we set them to another list.&lt;/li&gt;
&lt;li&gt;Overall they will traverse the same distance and reach and the intersection point if one exists or become &lt;code&gt;null&lt;/code&gt; at the same time in second iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p160/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O (n)&lt;/code&gt; where n is the size of larger list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>105. Construct Binary Tree from Preorder and Inorder Traversal</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume that duplicates do not exist in the tree.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/654-maximum-binary-tree/"&gt;654. Maximum Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The pattern to notice here is that the root of the subtree always comes firt&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link><guid isPermaLink="false">59c8168e018514b5e1fc0948</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 20:49:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume that duplicates do not exist in the tree.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="http://dtprogrammer.github.io/654-maximum-binary-tree/"&gt;654. Maximum Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The pattern to notice here is that the root of the subtree always comes firt in the preorder traversal and in middle in inorder traversal.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;In:  D B E A F C
Pre: A B D E C F
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;We take the first element in the preorder traversal find it in the inorder traversal. Now the elements to the left to it inorder traversal is the left subtree and right to it is the inorder traversal of the right subtree.&lt;/li&gt;
&lt;li&gt;The next element in the preorder traversal is the root of the left subtree (if one exists)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/wA8vSGZ.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p105/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The time complexity in average case will be &lt;code&gt;O (n log n)&lt;/code&gt;. Since the height of the tree will be &lt;code&gt;log n&lt;/code&gt; and finding the element takes &lt;code&gt;O (n)&lt;/code&gt; time. Although, worst case we might end up with skewed tree and the height of tree will become &lt;code&gt;n&lt;/code&gt;  and the time complexity will become &lt;code&gt;O (n pow 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The time complexity can be improved to &lt;code&gt;O (n)&lt;/code&gt; by first creating a &lt;code&gt;HashTable&lt;/code&gt; which maps the keys to their positions inorder traversal. Building this &lt;code&gt;HashTable&lt;/code&gt; takes &lt;code&gt;O (n)&lt;/code&gt; time although the space complexity will increase to &lt;code&gt;O (n + h)&lt;/code&gt; where n is the space taken by the hashtable and h is height of the tree (recursion stack).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant besides the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Many different trees gives the same sequence of keys in an inorder, preorder or postorder traversal.&lt;/li&gt;
&lt;li&gt;Although, if an inorder traversal and one more (preorder or postorder) traversal is given then there exists only one unique binary tree, given the nodes hold unique values.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>283. Move Zeroes</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/move-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/283-move-zeroes/</link><guid isPermaLink="false">59c7fa90018514b5e1fc0946</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 24 Sep 2017 18:34:45 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/move-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must do this in-place without making a copy of the array.&lt;br&gt;
Minimize the total number of operations.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p283/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
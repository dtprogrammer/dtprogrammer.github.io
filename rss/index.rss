<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Mon, 02 Oct 2017 15:31:13 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>162. Find Peak Element</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-peak-element/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/162-find-peak-element/</link><guid isPermaLink="false">59d25a6deb9941586725f973</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 02 Oct 2017 15:26:47 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-peak-element/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;/p&gt;
&lt;p&gt;You may imagine that num[-1] = num[n] = -∞.&lt;/p&gt;
&lt;p&gt;For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.&lt;/p&gt;
&lt;p&gt;click to show spoilers.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
Your solution should be in logarithmic complexity.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Binary search&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A very good guide to solve this problem is present &lt;a href="https://leetcode.com/problems/find-peak-element/solution/"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The idea here is that we can use binary search. If &lt;code&gt;nums(i) &amp;lt; nums(i+1)&lt;/code&gt; we know that the peak exists towards the right and we can make our &lt;code&gt;low&lt;/code&gt; boundary &lt;code&gt;mid + 1&lt;/code&gt; else we make our high boundary &lt;code&gt;mid&lt;/code&gt; since the mid itself can be peak.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p162/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (log n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>328. Odd Even Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/odd-even-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/328-odd-even-linked-list/</link><guid isPermaLink="false">59d16a5beb9941586725f971</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 22:23:32 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/odd-even-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;
return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;
The first node is considered odd, the second node even and so on ...&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Odd even pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n)&lt;/code&gt; time complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p328/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>114. Flatten Binary Tree to Linked List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, flatten it to a linked list in-place.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1
        / \
       2   5
      / \   \
     3   4   6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The flattened tree should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Postorder traversal&lt;/li&gt;
&lt;li&gt;right and then left&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="initialsolution"&gt;Initial solution:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;I was able to implement this&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/114-flatten-binary-tree-to-linked-list/</link><guid isPermaLink="false">59d03ac0eb9941586725f96d</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 00:51:45 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, flatten it to a linked list in-place.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         1
        / \
       2   5
      / \   \
     3   4   6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The flattened tree should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Postorder traversal&lt;/li&gt;
&lt;li&gt;right and then left&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="initialsolution"&gt;Initial solution:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;I was able to implement this solution which passed leetcode OJ. Although, this is not efficient&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        flatten(root.left);
        flatten(root.right);
        if (root.left != null) {
            TreeNode target = root.left;
            while (target.right != null) {
                target = target.right;
            }
            target.right = root.right;
            root.right = root.left;
            root.left = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="optimalsolution"&gt;Optimal Solution:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;The optimal way to solve this is to do &lt;code&gt;postorder&lt;/code&gt; traversal visiting the right node followed by the left.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p114/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O(1)&lt;/code&gt; except the space on stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>287. Find the Duplicate Number</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-the-duplicate-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must not modify the array (assume the array is&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/287-find-the-duplicate-number/</link><guid isPermaLink="false">59d02c76eb9941586725f96c</guid><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 01 Oct 2017 00:44:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/find-the-duplicate-number/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You must not modify the array (assume the array is read only).&lt;br&gt;
You must use only constant, O(1) extra space.&lt;br&gt;
Your runtime complexity should be less than O(n2).&lt;br&gt;
There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Binary search on values of array&lt;/li&gt;
&lt;li&gt;Linkedlist cycle detection&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;This approach runs a binary search between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p287/Solution2.java"&gt;&lt;/script&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;This approach models the problem as linkedlist and detects cycle entry point&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p287/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (n log n)&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="approach2"&gt;Approach 2:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;h5 id="approach1"&gt;Approach 1:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (1)&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="approach2"&gt;Approach 2:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;O (1)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>242. Valid Anagram</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/valid-anagram/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;, return true.
s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;, return false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume the string contains only lowercase&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/242-valid-anagram/</link><guid isPermaLink="false">59cfe96ceb9941586725f96a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 30 Sep 2017 19:01:12 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/valid-anagram/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;, return true.
s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;, return false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume the string contains only lowercase alphabets.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
What if the inputs contain unicode characters? How would you adapt your solution to such case?&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use an array indexed by ascii code&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We can use &lt;code&gt;HashTable&lt;/code&gt; for unicode charset&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p242/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + m)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant for ascii charset. For unicode charset we will use HashTable and complexity will become &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>227. Basic Calculator II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/basic-calculator-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
&lt;p&gt;The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.&lt;/p&gt;
&lt;p&gt;You may assume that the given expression is always valid.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;3+2*2&amp;quot; = 7
&amp;quot; 3/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/227-basic-calculator-ii/</link><guid isPermaLink="false">59cfe506eb9941586725f968</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 30 Sep 2017 18:44:12 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/basic-calculator-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
&lt;p&gt;The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.&lt;/p&gt;
&lt;p&gt;You may assume that the given expression is always valid.&lt;/p&gt;
&lt;p&gt;Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;3+2*2&amp;quot; = 7
&amp;quot; 3/2 &amp;quot; = 1
&amp;quot; 3+5 / 2 &amp;quot; = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: Do not use the eval built-in library function.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use a &lt;code&gt;Stack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Do &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; first&lt;/li&gt;
&lt;li&gt;Push &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; with correct sign for the number&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p227/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; taken by stack in case if all operators are &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>378. Kth Smallest Element in a Sorted Matrix</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.&lt;/p&gt;
&lt;p&gt;Note that it is the kth smallest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;matrix = [
   [ 1,  5,  9],
   [10,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/378-kth-smallest-element-in-a-sorted-matrix/</link><guid isPermaLink="false">59cc44e286a7c704df1334d3</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Thu, 28 Sep 2017 00:42:56 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.&lt;/p&gt;
&lt;p&gt;Note that it is the kth smallest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return 13.&lt;br&gt;
Note:&lt;br&gt;
You may assume k is always valid, 1 ≤ k ≤ n2.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; for row or column&lt;/li&gt;
&lt;li&gt;Keep popping and updating till k&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p378/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + k log(n))&lt;/code&gt; where n is the number of columns&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; taken by the priority queue&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>85. Maximal Rectangle</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximal-rectangle/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.&lt;/p&gt;
&lt;p&gt;For example, given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return 6.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/85-maximal-rectangle/</link><guid isPermaLink="false">59cbe139a588803d1e4d5b99</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 17:39:49 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximal-rectangle/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.&lt;/p&gt;
&lt;p&gt;For example, given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return 6.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;We need to find the &lt;code&gt;left boundary start&lt;/code&gt;, &lt;code&gt;right boundary start&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Use three single dimension array to keep track of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is very similar to &lt;a href="https://dtprogrammer.github.io/221-maximal-square/"&gt;221. Maximal Square&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We iterate through all rows.&lt;/li&gt;
&lt;li&gt;For every row we track the &lt;code&gt;left&lt;/code&gt; boundary, &lt;code&gt;right&lt;/code&gt; boundary and &lt;code&gt;height&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;left(i,j) = max(left(i-1,j), cur_left), cur_left can be determined from the current row&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;right(i,j) = min(right(i-1,j), cur_right), cur_right can be determined from the current row&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;height(i,j) = height(i-1,j) + 1, if matrix[i][j]=='1' else height(i,j) = 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p85/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (m * n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (3n)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>Hadoop The Definitive Guide</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h1 id="booksummary"&gt;Book Summary&lt;/h1&gt;
&lt;p&gt;This is a summary and notes from Hadoop The Definitive Guide 4th Edition.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;more data usually beats better algorithms&lt;/li&gt;
&lt;li&gt;In a nutshell, this is what Hadoop provides: a reliable, scalable platform for storage and analysis.&lt;/li&gt;
&lt;li&gt;MapReduce is a batch query processor, and the ability to run an&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/hadoop-the-definitive-guide/</link><guid isPermaLink="false">59cb5b4fa588803d1e4d5b96</guid><category>distributed-systems</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 08:17:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h1 id="booksummary"&gt;Book Summary&lt;/h1&gt;
&lt;p&gt;This is a summary and notes from Hadoop The Definitive Guide 4th Edition.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;more data usually beats better algorithms&lt;/li&gt;
&lt;li&gt;In a nutshell, this is what Hadoop provides: a reliable, scalable platform for storage and analysis.&lt;/li&gt;
&lt;li&gt;MapReduce is a batch query processor, and the ability to run an ad hoc query against your whole dataset and get the results in a reasonable time is transformative.&lt;/li&gt;
&lt;li&gt;seek time is improving more slowly than transfer rate.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chapter2mapreduce3"&gt;Chapter 2: MapReduce3&lt;/h2&gt;
&lt;h3 id="dataflow"&gt;Data Flow&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;MapReduce job&lt;/code&gt; is a unit of work that the client wants to be performed: it consists of the input data, the MapReduce program, and configuration information.&lt;/li&gt;
&lt;li&gt;Hadoop runs the job by dividing it into tasks, of which there are two types: &lt;code&gt;map tasks&lt;/code&gt; and &lt;code&gt;reduce tasks&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The tasks are scheduled using YARN and run on nodes in the cluster. If a task fails, it will be automatically rescheduled to run on a different node.&lt;/li&gt;
&lt;li&gt;Hadoop divides the input to a MapReduce job into fixed-size pieces called &lt;code&gt;input splits&lt;/code&gt;, or just splits.&lt;/li&gt;
&lt;li&gt;Hadoop creates one map task for each split, which runs the user-defined map function for each record in the split.&lt;/li&gt;
&lt;li&gt;Having many splits means the time taken to process each split is small compared to the time to process the whole input.&lt;/li&gt;
&lt;li&gt;On the other hand, if splits are too small, the overhead of managing the splits and map task creation begins to dominate the total job execution time.&lt;/li&gt;
&lt;li&gt;For most jobs, a good split size tends to be the size of an &lt;code&gt;HDFS block&lt;/code&gt;, which is 128 MB by default.&lt;/li&gt;
&lt;li&gt;Hadoop does its best to run the map task on a node where the input data resides in HDFS, because it doesn’t use valuable cluster bandwidth. This is called the &lt;code&gt;data locality optimization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Map tasks write their output to the &lt;code&gt;local disk&lt;/code&gt;, not to HDFS. Why is this? Map output is intermediate output: it’s processed by reduce tasks to produce the final output, and once the job is complete, the map output can be thrown away. So, storing it in HDFS with replication would be overkill.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/KSeXaal.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reduce tasks don’t have the advantage of data locality&lt;/code&gt;; the input to a single reduce task is normally the output from all mappers. In the present example, we have a single reduce task that is fed by all of the map tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/HFucObH.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When there are multiple reducers, the map tasks partition their output, each creating one partition for each reduce task. There can be many keys (and their associated values) in each partition, but the records for any given key are all in a single partition.&lt;/li&gt;
&lt;li&gt;The above diagram makes it clear why the data flow between map and reduce tasks is collo‐ quially known as “the shuffle,” as each reduce task is fed by many map tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="combinerfunctions"&gt;Combiner Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Many MapReduce jobs are limited by the bandwidth available on the cluster, so it pays to minimize the data transferred between map and reduce tasks. Hadoop allows the user to specify a combiner function to be run on the map output, and the combiner function’s output forms the input to the reduce function.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chapter3thehadoopdistributedfilesystem"&gt;Chapter 3: The Hadoop Distributed Filesystem&lt;/h2&gt;
&lt;/div&gt;</content:encoded></item><item><title>221. Maximal Square</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximal-square/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.&lt;/p&gt;
&lt;p&gt;For example, given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return 4.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/221-maximal-square/</link><guid isPermaLink="false">59cb5757a588803d1e4d5b94</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 07:52:23 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/maximal-square/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.&lt;/p&gt;
&lt;p&gt;For example, given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return 4.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;br&gt;
&lt;img src="https://i.imgur.com/8gHUcnd.png" alt=""&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/meiI5ic.png" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p221/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (m * n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>300. Longest Increasing Subsequence</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/longest-increasing-subsequence/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [10, 9, 2, 5, 3, 7, 101, 18],&lt;br&gt;
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/300-longest-increasing-subsequence/</link><guid isPermaLink="false">59cb1ee2a588803d1e4d5b8f</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 03:52:04 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/longest-increasing-subsequence/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [10, 9, 2, 5, 3, 7, 101, 18],&lt;br&gt;
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.&lt;/p&gt;
&lt;p&gt;Your algorithm should run in O(n2) complexity.&lt;/p&gt;
&lt;p&gt;Follow up: Could you improve it to O(n log n) time complexity?&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;If the current element is greater then update&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;To calculate a value of length(k), we should find a position i &amp;lt; k for which array[i] &amp;lt; array[k] and length(i) is as large as possible. Then we know that length(k) = length(i) + 1, because this is an optimal way to add array[k] to a subsequence. However, if there is no such position i, then length(k) = 1&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p300/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n ^ 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>518. Coin Change 2</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change-2/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.&lt;/p&gt;
&lt;p&gt;Note: You can assume that&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= amount &amp;lt;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/518-coin-change-2/</link><guid isPermaLink="false">59cb0af0a588803d1e4d5b89</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 27 Sep 2017 02:58:25 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change-2/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.&lt;/p&gt;
&lt;p&gt;Note: You can assume that&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= amount &amp;lt;= 5000&lt;br&gt;
1 &amp;lt;= coin &amp;lt;= 5000&lt;br&gt;
the number of coins is less than 500&lt;br&gt;
the answer is guaranteed to fit into signed 32-bit integer&lt;br&gt;
Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: amount = 10, coins = [10] 
Output: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;amount - all coin value&lt;/li&gt;
&lt;li&gt;Dynamic programming&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[0] = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;iterate through coins first&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is very similar to &lt;a href="https://dtprogrammer.github.io/322-coin-change/"&gt;322. Coin Change&lt;/a&gt;. All we need to do here is keep a count rather than tracking minimum.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/hwS4hF2.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p518/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (k * n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the amount and &lt;code&gt;k&lt;/code&gt; is the number of coins denominations.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + 1)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>322. Coin Change</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/322-coin-change/</link><guid isPermaLink="false">59ca09e4a588803d1e4d5a77</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 08:06:21 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/coin-change/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
coins = [1, 2, 5], amount = 11&lt;br&gt;
return 3 (11 = 5 + 5 + 1)&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
coins = [2], amount = 3&lt;br&gt;
return -1.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You may assume that you have an infinite number of each kind of coin.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Use memoization to calculate&lt;/li&gt;
&lt;li&gt;amount - all coin value&lt;/li&gt;
&lt;li&gt;Dynamic programming&lt;/li&gt;
&lt;li&gt;initially min is -1 and then do the calculation&lt;/li&gt;
&lt;li&gt;min of all the  possible ways&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;value[0] = 0;
for (int x = 1; x &amp;lt;= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
       if (x-c &amp;gt;= 0) {
           value[x] = min(value[x], value[x-c]+1);
           } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p322/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n * k)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the amount and &lt;code&gt;k&lt;/code&gt; is the number of coins denominations.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n + 1)&lt;/code&gt; for memoization&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>Dynamic Programming</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic programming is a technique that combines the correctness of com- plete search and the efficiency of greedy algorithms.&lt;/li&gt;
&lt;li&gt;Dynamic programming can be applied if the problem can be divided into overlapping subproblems that can be solved independently.&lt;/li&gt;
&lt;li&gt;There are two uses for dynamic programming:
&lt;ul&gt;
&lt;li&gt;Finding an optimal solution:&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/dynamic-programming/</link><guid isPermaLink="false">59c9f9e2a588803d1e4d5a74</guid><category>Algorithms</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 07:21:13 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic programming is a technique that combines the correctness of com- plete search and the efficiency of greedy algorithms.&lt;/li&gt;
&lt;li&gt;Dynamic programming can be applied if the problem can be divided into overlapping subproblems that can be solved independently.&lt;/li&gt;
&lt;li&gt;There are two uses for dynamic programming:
&lt;ul&gt;
&lt;li&gt;Finding an optimal solution: We want to find a solution that is as large as possible or as small as possible.&lt;/li&gt;
&lt;li&gt;Counting the number of solutions: We want to calculate the total num- ber of possible solutions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dynamic programming algorithm is efficient because it uses memoization and calculates the answer to each subproblem only once.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="problems"&gt;Problems&lt;/h2&gt;
&lt;h3 id="coinproblem"&gt;Coin Problem&lt;/h3&gt;
&lt;p&gt;If types of coins = {1, 3, 4}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solve(x) = min(solve(x - 1) + 1, solve(x - 3) + 1, solve(x - 4) + 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/x2m4Mh0.png" alt=""&gt;&lt;/p&gt;
&lt;h4 id="recursivesolution"&gt;Recursive Solution&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;int solve(int x) {
    if (x &amp;lt; 0) return INF;
    if (x == 0) return 0;
    if (ready[x]) return value[x];
    int best = INF;
    for (auto c : coins) {
       best = min(best, solve(x-c)+1);
    }
    value[x] = best;
    ready[x] = true;
    return best;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where ready[x] indicates whether the value of solve(x) has been calculated, and if it is, value[x] contains this value.&lt;/p&gt;
&lt;h4 id="iterativesolution"&gt;Iterative Solution&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;value[0] = 0;
for (int x = 1; x &amp;lt;= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
       if (x-c &amp;gt;= 0) {
           value[x] = min(value[x], value[x-c]+1);
           } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The time complexity of the algorithm is &lt;code&gt;O(nk)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the target sum and &lt;code&gt;k&lt;/code&gt; is the number of coins.&lt;/p&gt;
&lt;p&gt;In the coin problem, for example, we can declare another array that indicates for each sum of money the first coin in an optimal solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value[0] = 0;
for (int x = 1; x &amp;lt;= n; x++) {
    value[x] = INF;
    for (auto c : coins) {
       if (x-c &amp;gt;= 0 &amp;amp;&amp;amp; value[x-c]+1 &amp;lt; value[x]) {
           value[x] = value[x-c]+1;
           first[x] = c;
           } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="printingsolution"&gt;Printing Solution&lt;/h4&gt;
&lt;p&gt;After this, the following code can be used to print the coins that appear in an optimal solution for the sum n:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (n &amp;gt; 0) {
    cout &amp;lt;&amp;lt; first[n] &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    n -= first[n];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="countingsolution"&gt;Counting Solution&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;solve(x) =solve(x - 1) + solve(x - 3) + solve(x - 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/OMzPKkV.png" alt=""&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count[0] = 1;
for (int x = 1; x &amp;lt;= n; i++) {
    for (auto c : coins) {
       if (x-c &amp;gt;= 0) {
           count[x] += count[x-c];
       }
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="longestincreasingsubsequence"&gt;Longest Increasing Subsequence&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This is a maximum-length sequence of array elements that goes from left to right, and each element in the sequence is larger than the previous element.&lt;/li&gt;
&lt;li&gt;To calculate a value of length(k), we should find a position i &amp;lt; k for which array[i] &amp;lt; array[k] and length(i) is as large as possible. Then we know that length(k) = length(i) + 1, because this is an optimal way to add array[k] to a subsequence. However, if there is no such position i, then length(k) = 1, which means that the subsequence only contains array[k].&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for (int k = 0; k &amp;lt; n; k++) {
    length[k] = 1;
    for (int i = 0; i &amp;lt; k; i++) {
       if (array[i] &amp;lt; array[k]) {
           length[k] = max(length[k],length[i]+1);
       }
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="longestincreasingsubsequence"&gt;Longest Increasing Subsequence&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/AQlumT4.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/f1C8dQl.png" alt=""&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int y = 1; y &amp;lt;= n; y++) {
    for (int x = 1; x &amp;lt;= n; x++) {
       sum[y][x] = max(sum[y][x-1],sum[y-1][x])+value[y][x];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Time complexity: &lt;code&gt;O(n ^ 2)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="knapsackproblems"&gt;Knapsack problems&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>139. Word Break</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/word-break/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.&lt;/p&gt;
&lt;p&gt;For example, given&lt;br&gt;
s = &amp;quot;leetcode&amp;quot;,&lt;br&gt;
dict&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/139-word-break/</link><guid isPermaLink="false">59c9f537a588803d1e4d5a72</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 26 Sep 2017 06:48:59 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/word-break/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.&lt;/p&gt;
&lt;p&gt;For example, given&lt;br&gt;
s = &amp;quot;leetcode&amp;quot;,&lt;br&gt;
dict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;].&lt;/p&gt;
&lt;p&gt;Return true because &amp;quot;leetcode&amp;quot; can be segmented as &amp;quot;leet code&amp;quot;.&lt;/p&gt;
&lt;p&gt;UPDATE (2017/1/4):&lt;br&gt;
The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.&lt;/p&gt;
&lt;h3 id="quickhints"&gt;Quick Hints&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;keep a boolean array to track till which position the word is valid when broken&lt;/li&gt;
&lt;li&gt;array[0] is always valid since its empty&lt;/li&gt;
&lt;li&gt;Break the string and update the boolean array&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p139/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n pow 2)&lt;/code&gt; where n is the dictionary size. This is because the lookup in the dictionary takes &lt;code&gt;O (n)&lt;/code&gt; time.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;O (n)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>
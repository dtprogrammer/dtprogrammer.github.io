<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Software Interview Preparation Blog</title><description>Algorithms, Data Structures and System Design for Interviews</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Software Interview Preparation Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Mon, 18 Sep 2017 06:20:19 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>46. Permutations</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,2,3] have the following permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same domain as &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The idea&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/46-permutations/</link><guid isPermaLink="false">59bf63c2a7b0fe3c2805e818</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 18 Sep 2017 06:19:31 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/permutations/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
[1,2,3] have the following permutations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is of same domain as &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The idea here is to generate all permutation through recursion.&lt;/li&gt;
&lt;li&gt;We need to keep a track of whether we have included the element in the &lt;code&gt;tempList&lt;/code&gt; or not because in case say we added &lt;code&gt;1, 2, 3&lt;/code&gt; now when recursion unwinds and 3 and 2 is removed from the stack. The for loops moves and generate a call with &lt;code&gt;tempList&lt;/code&gt; as &lt;code&gt;1, 3&lt;/code&gt; now we don't want to add 1 again.&lt;/li&gt;
&lt;li&gt;A general approach can be found in &lt;a href="https://cses.fi/book.pdf"&gt;5.2  of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search() {
    if (permutation.size() == n) {
        // process permutation
    } else {
        for (int i = 0; i &amp;lt; n; i++) {
            if (chosen[i]) continue;
            chosen[i] = true;
            permutation.push_back(i);
            search();
            chosen[i] = false;
            permutation.pop_back();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p46/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track and the space taken by the Set to keep track of all possibe unique combination seen so far which in worse case (all unique numbers) will be equal to all possible combinations.&lt;br&gt;
Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We don't make recursive call after pop since we don't want to generate a subset where any of the elements in &lt;code&gt;nums&lt;/code&gt; is not a part as its in the case of combination.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>90. Subsets II</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,2], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78.&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/90-subsets-ii/</link><guid isPermaLink="false">59bf58faa7b0fe3c2805e814</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 18 Sep 2017 05:42:16 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets-ii/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,2], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This problem is similar to &lt;a href="https://dtprogrammer.github.io/78-subsets/"&gt;78. Subsets&lt;/a&gt; with the only difference that the &lt;code&gt;nums&lt;/code&gt; array can have duplicates.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p90/Solution.java"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;We use a Set to keep track of subsets which we have seen so far and recursed on.&lt;/li&gt;
&lt;li&gt;We also sort the array. This ensures that the Set contains is always checked for for a sorted/fixed order of numbers. For example in case of &lt;code&gt;1, 4, 4&lt;/code&gt; and &lt;code&gt;4, 1, 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Also, the pop and recurse is not done outside of the contains block so that the recursion unwindws all the way through and we get all possible combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track and the space taken by the Set to keep track of all possibe unique combination seen so far which in worse case (all unique numbers) will be equal to all possible combinations.&lt;br&gt;
Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>78. Subsets</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,3], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This &lt;a href="https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning"&gt;discussion&lt;/a&gt; is very helpful in&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/78-subsets/</link><guid isPermaLink="false">59bf1302a7b0fe3c2805e810</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 18 Sep 2017 02:00:46 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/subsets/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
If nums = [1,2,3], a solution is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This &lt;a href="https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning"&gt;discussion&lt;/a&gt; is very helpful in understanding the general pattern to solve this problem.&lt;/li&gt;
&lt;li&gt;It is very important to understand the recursive call for this solution and how the recursion unwinds.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/eKTJpwF.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p78/Solution.java"&gt;&lt;/script&gt;
&lt;p&gt;The time complexity of the above approach is hard to analyze. Another way to solve this problem which is easier to understand and analyze is below.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p78/StackBasedSolution.java"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;The general idea can can be found in &lt;a href="https://cses.fi/book.pdf"&gt;Chapter 5 of Competitive Programmer's Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void search(int k) {
    if (k == n) {
        // process subset
    } else {
        search(k+1);
        subset.push_back(k);
        search(k+1);
        subset.pop_back();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) which is the space taken by the stack to keep track. Also the solution uses recursion so it does take some space on call stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>56. Merge Intervals</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/merge-intervals/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [1,3],[2,6],[8,10],[15,18],&lt;br&gt;
return [1,6],[8,10],[15,18].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is straightforward. We can only overlap two intervals of the &lt;code&gt;start time&lt;/code&gt; of the second intervals is &lt;code&gt;&amp;lt;=&lt;/code&gt; to&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/56-merge-intervals/</link><guid isPermaLink="false">59beb645a7b0fe3c2805e80a</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 17:57:12 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/merge-intervals/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given [1,3],[2,6],[8,10],[15,18],&lt;br&gt;
return [1,6],[8,10],[15,18].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is straightforward. We can only overlap two intervals of the &lt;code&gt;start time&lt;/code&gt; of the second intervals is &lt;code&gt;&amp;lt;=&lt;/code&gt; to the &lt;code&gt;end time&lt;/code&gt; of the first interval.&lt;/li&gt;
&lt;li&gt;We will first need to sort the intervals on basis of the start time so that we are guranteed to see the start time in increasing sequence.&lt;/li&gt;
&lt;li&gt;We also need to keep a track of the &lt;code&gt;max&lt;/code&gt; end time for the overlapping intervals seen so far. This is needed because since &lt;code&gt;end time&lt;/code&gt; is not sorted we might see them in any order but all we care is the &lt;code&gt;max&lt;/code&gt; to create the merged interval.&lt;/li&gt;
&lt;li&gt;Once we see an interval which does not overlap anymore we add our last one, reset and continue.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p56/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity to sort is O (n * log n) and then to merge is O (n) so the overall time complexity if O (n * log n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>54. Spiral Matrix</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/spiral-matrix/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should return [1,2,3,6,9,8,7,4,5].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;&lt;/div&gt;</description><link>http://localhost:2368/54-spiral-matrix/</link><guid isPermaLink="false">59be2d56a7b0fe3c2805e808</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 08:12:05 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/spiral-matrix/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
Given the following matrix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should return [1,2,3,6,9,8,7,4,5].&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The problem is straight forward. We just need to keep track of the processed rows and columns so that we avoid them in spiral traversal.&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p54/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (m * n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;We only go right to left and/or down to up only if the there is remaing rows and remaining columns respectively.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>103. Binary Tree Zigzag Level Order Traversal</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/103-binary-tree-zigzag-level-order-traversal/</link><guid isPermaLink="false">59be25cba7b0fe3c2805e806</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 07:39:27 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its zigzag level order traversal as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [20,9],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This problem is very similar to &lt;a href="http://dtprogrammer.github.io/102-binary-tree-level-order-traversal/"&gt;102. Binary Tree Level Order Traversal&lt;/a&gt;. We just need to reverse the order while traversing down the level.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This might be achieved by inserting the items in the queue in the desired way but an easier approach is to insert them in the result list in the desired way. The below solution takes this approach.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p103/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) since in worst case we might end up with all the nodes in level and have to keep them in queue&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>102. Binary Tree Level Order Traversal</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its level order traversal as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [9,20],
  [15,7]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/102-binary-tree-level-order-traversal/</link><guid isPermaLink="false">59bdc286a7b0fe3c2805e802</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sun, 17 Sep 2017 00:36:48 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return its level order traversal as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  [3],
  [9,20],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem is really simple. It just need a BFS traversal of the tree with a way to track when a level ends. For this we keep a counter for levelSize which tracks the number of elements at each level.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p102/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;O (n) since in worst case we might end up with all the nodes in level and have to keep them in queue&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;/div&gt;</content:encoded></item><item><title>73. Set Matrix Zeroes</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/set-matrix-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.&lt;/p&gt;
&lt;p&gt;click to show follow up.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Did you use extra space?&lt;br&gt;
A straight forward solution using O(mn) space is probably a bad idea.&lt;br&gt;
A&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/73-set-matrix-zeroes/</link><guid isPermaLink="false">59bdb2d9a7b0fe3c2805e800</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Sat, 16 Sep 2017 23:31:21 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/set-matrix-zeroes/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.&lt;/p&gt;
&lt;p&gt;click to show follow up.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
Did you use extra space?&lt;br&gt;
A straight forward solution using O(mn) space is probably a bad idea.&lt;br&gt;
A simple improvement uses O(m + n) space, but still not the best solution.&lt;br&gt;
Could you devise a constant space solution?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;I was not able to solve the problem initially with constant space. I ended up looking up discussions.&lt;/p&gt;
&lt;p&gt;The idea is to use &lt;code&gt;&amp;lt;i, 0&amp;gt;&lt;/code&gt; as marker for row and &lt;code&gt;&amp;lt;0, j&amp;gt;&lt;/code&gt; as marked for column. Now &lt;code&gt;&amp;lt;0, 0&amp;gt;&lt;/code&gt; becomes special case because it's needed for marking both 0th row and 0th column. So we use it just for the row and we use another variable col0 to store column marking for 0th column.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p73/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O(m * n)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is important to traverse from the bottom-right end while setting to 0 since if we travel from top-left we will set the first row 0 if there is even one zero which in turn will set everything to 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/236-lowest-common-ancestor-of-a-binary-tree/</link><guid isPermaLink="false">59bb8b12a7b0fe3c2805e7fc</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Fri, 15 Sep 2017 08:26:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem can be solved in different possible ways. EPI also has a solution for this which is pretty lengthy. The &lt;code&gt;Discuss&lt;/code&gt; section on leetcode have a very simple solution which I learned and replicated.&lt;/p&gt;
&lt;p&gt;There are two possibilities here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The nodes are in different subtree&lt;/li&gt;
&lt;li&gt;One of the nodes itself is the root.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With the above, we can write the solution below in which if the subtree contains both the nodes then the result is subtree root itself. If it contains either of the nodes then results is that node. If none of the above cause is true then it returns null.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/KyrLj5W.jpg" alt=""&gt;&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p236/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O(n) since we traverse the tree to find the LCA.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;The space complexity is constant although since the algorithm uses recursion there is O(log n = h) space required on the stack&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;If left is null return right, if right is null return left, if both are null the root itself is returned.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>130. Surrounded Regions</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/surrounded-regions/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all 'O's into 'X's in that surrounded region.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
X X X X&lt;br&gt;
X O O X&lt;br&gt;
X X O X&lt;br&gt;
X O X X&lt;br&gt;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/130-surrounded-regions/</link><guid isPermaLink="false">59b8da5a301d231e36fc8fe7</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 07:25:54 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/surrounded-regions/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all 'O's into 'X's in that surrounded region.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;
X X X X&lt;br&gt;
X O O X&lt;br&gt;
X X O X&lt;br&gt;
X O X X&lt;br&gt;
After running your function, the board should be:&lt;/p&gt;
&lt;p&gt;X X X X&lt;br&gt;
X X X X&lt;br&gt;
X X X X&lt;br&gt;
X O X X&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;I was able to think of the solution since I have seen this problem long back. The trick here is to notice is that if any of the boundary (left, right, up, down) has &lt;code&gt;O&lt;/code&gt; then that will remain &lt;code&gt;0&lt;/code&gt; as it has an open surrounding. Now this &lt;code&gt;O&lt;/code&gt; will cause other &lt;code&gt;O&lt;/code&gt; to remain &lt;code&gt;O&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So overall the idea is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For all &lt;code&gt;O&lt;/code&gt; present in boundaries and its connected &lt;code&gt;O&lt;/code&gt; mark it with some other character. Here we choose &lt;code&gt;*&lt;/code&gt; as we know for certain they will remain &lt;code&gt;O&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now everything else can marked &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Switch &lt;code&gt;*&lt;/code&gt; back to &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My initial solution was as below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public void solve(char[][] board) {
        // flip all 0 from borders to *
        if (board != null &amp;amp;&amp;amp; board.length != 0) {
            // mark from all boundaries
            // top
            markFromBorder(board, 0, 1, 0, board[0].length);
            // bottom
            markFromBorder(board, board.length - 1, board.length, 0, board[board.length - 1].length);
            // left
            markFromBorder(board, 0, board.length, 0, 1);
            // right
            markFromBorder(board, 0, board.length, board[0].length - 1, board[0].length);
            // now mark all remaining O to X
            replaceInMatrix(board, 'O', 'X');
            replaceInMatrix(board, '*', 'O');
        }
    }

    private void replaceInMatrix(char[][] board, Character charToReplace, Character replacingChar) {
        for (int i = 0; i &amp;lt; board.length; i++) {
            for (int j = 0; j &amp;lt; board[i].length; j++) {
                if (board[i][j] == charToReplace) {
                    board[i][j] = replacingChar;
                }
            }
        }
    }

    private void markFromBorder(char[][] board, int rowStart, int rowEnd, int colStart, int colEnd) {
        for (int i = rowStart; i &amp;lt; rowEnd; i++) {
            for (int j = colStart; j &amp;lt; colEnd; j++) {
                markWithNeighbors(board, i, j);
            }
        }
    }

    private void markWithNeighbors(char[][] board, int row, int col) {
        // base case
        if (row &amp;lt; 0 || row &amp;gt;= board.length || col &amp;lt; 0 || col &amp;gt;= board[row].length) {
            return;
        }
        if (board[row][col] == 'O') {
            // mark
            board[row][col] = '*';
            // handle neighbors
            markWithNeighbors(board, row + 1, col);
            markWithNeighbors(board, row - 1, col);
            markWithNeighbors(board, row, col + 1);
            markWithNeighbors(board, row, col - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this did work for most test case it failed for one of the test cases with stack overflow. Apparently, for one of the test case leetcode checks the number of the recursive call made to be under a limit. The solution is a DFS method where the max depth of recurses should be the size of matrix i.e. N. Since, my solution makes more recursive call it failed. Later, I was able to modify my solution to make less recursive call with the help of this &lt;a href="https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms/18"&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p130/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N * N)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant. Although since we are using recursive approach the solution does take some space in the recursion stack.&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Recurse only for &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Recurse only if the range is valid&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>75. Sort Colors</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/sort-colors/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;
&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/75-sort-colors/</link><guid isPermaLink="false">59b8c5cd301d231e36fc8fe5</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 05:58:10 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/sort-colors/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;
&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You are not suppose to use the library's sort function for this problem.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;
A rather straight forward solution is a two-pass algorithm using counting sort.&lt;br&gt;
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.&lt;/p&gt;
&lt;p&gt;Could you come up with an one-pass algorithm using only constant space?&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This is typical &lt;a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem"&gt;Dutch National Flag&lt;/a&gt; problem in which we choose a pivot and move elements smaller than the pivot towards the left and larger towards the right.&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p75/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N)&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Higher index start from the last element/index of the array and moves left through decrement.&lt;/li&gt;
&lt;li&gt;When we swap an element towards higher side we don't increment equal because the number coming from higher end might be less or equal than the pivot so we need to process it still.&lt;/li&gt;
&lt;li&gt;In case of swapping an element towards lower side we move the lower and equal both since we have already processed the left end before equal index and we know for certain that the element which is being moved to current equal index is either smaller or equal to pivot.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>49. Group Anagrams</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/group-anagrams/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;
&lt;p&gt;For example, given: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;],&lt;br&gt;
Return:&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;br&gt;
[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;br&gt;
[&amp;quot;bat&amp;quot;]&lt;br&gt;
]&lt;br&gt;
Note:&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/49-group-anagrams/</link><guid isPermaLink="false">59b8a8a6301d231e36fc8fe3</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Wed, 13 Sep 2017 04:02:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/group-anagrams/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;
&lt;p&gt;For example, given: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;],&lt;br&gt;
Return:&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;br&gt;
[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;br&gt;
[&amp;quot;bat&amp;quot;]&lt;br&gt;
]&lt;br&gt;
Note: All inputs will be in lower-case.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;There are multiple ways to solve this problem.&lt;/p&gt;
&lt;h4 id="sorting"&gt;Sorting:&lt;/h4&gt;
&lt;p&gt;We can sort and generate a key to store in the HashMap although sorting will take O(N * M Log (M)) time where N is the number of strings and M is the average length of a string.&lt;/p&gt;
&lt;h4 id="primenumbermultiplication"&gt;Prime number Multiplication:&lt;/h4&gt;
&lt;p&gt;Another approach to solving this will be to assign a prime number to each character from a-z and then multiple. Since the product of two or more prime numbers is always unique we can use that to index. Although this is not a good solution as for a long string it can lead to overflow.&lt;/p&gt;
&lt;h4 id="charactercount"&gt;Character Count:&lt;/h4&gt;
&lt;p&gt;I came across this solution on &lt;a href="https://leetcode.com/problems/group-anagrams/solution/"&gt;leetcode solution&lt;/a&gt; for this problem. The idea is to generate the key for indexing through character occurrence count. The solution on leetcode uses # as a separator to separate the occurrence count so that it can create a string for hashing. Although this is not required. We can hash based on array elements. See the solution below:&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p49/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;The time complexity is O (N * M) where N is the number of string and M is the average size of a string.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;The space complexity is also O (N * M)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arrays.equal() can be used to compare two arrays for elements.&lt;/li&gt;
&lt;li&gt;Arrays.hashCode() can be used to generate the hashcode for array based on elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>50. Pow(x, n)</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/powx-n/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement pow(x, n).&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem is pretty simple although the two edge case which we need to handle are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x == 0&lt;/code&gt;: Leading to 1/x become infinite&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == Integer.MIN_VALUE&lt;/code&gt;: In this case &lt;code&gt;-n&lt;/code&gt; will overflow and come back to Integer.MIN_VALUE as its basically&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><link>http://localhost:2368/50-pow-x-n/</link><guid isPermaLink="false">59b782a3301d231e36fc8fe0</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 12 Sep 2017 06:54:16 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/powx-n/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement pow(x, n).&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem is pretty simple although the two edge case which we need to handle are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x == 0&lt;/code&gt;: Leading to 1/x become infinite&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == Integer.MIN_VALUE&lt;/code&gt;: In this case &lt;code&gt;-n&lt;/code&gt; will overflow and come back to Integer.MIN_VALUE as its basically a &lt;code&gt;Integer.MAX_VALUE + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p50/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;O (log n) since we reduce n by 2 in every step&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-Integer.MIN_VALUE == Integer.MIN_VALUE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Double.isInfinite()&lt;/em&gt; can returns true if the given number is infinitely large in magnitude&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>48. Rotate Image</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-image/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;
&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;
&lt;p&gt;Example&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/48-rotate-image/</link><guid isPermaLink="false">59b76e0d301d231e36fc8fde</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Tue, 12 Sep 2017 05:44:35 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/rotate-image/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;
&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;Given input matrix =&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[4,5,6],&lt;br&gt;
[7,8,9]&lt;br&gt;
],&lt;/p&gt;
&lt;p&gt;rotate the input matrix in-place such that it becomes:&lt;br&gt;
[&lt;br&gt;
[7,4,1],&lt;br&gt;
[8,5,2],&lt;br&gt;
[9,6,3]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;/p&gt;
&lt;p&gt;Given input matrix =&lt;br&gt;
[&lt;br&gt;
[ 5, 1, 9,11],&lt;br&gt;
[ 2, 4, 8,10],&lt;br&gt;
[13, 3, 6, 7],&lt;br&gt;
[15,14,12,16]&lt;br&gt;
],&lt;/p&gt;
&lt;p&gt;rotate the input matrix in-place such that it becomes:&lt;br&gt;
[&lt;br&gt;
[15,13, 2, 5],&lt;br&gt;
[14, 3, 4, 1],&lt;br&gt;
[12, 6, 8, 9],&lt;br&gt;
[16, 7,10,11]&lt;br&gt;
]&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;The problem can be solved easily if we remember a trick.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clockwise rotation: Swap up-down and then swap elements zig-zag&lt;/li&gt;
&lt;li&gt;Anticlockwise rotation: Swap left right and then swap elements zig-zag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example for the given matrix&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[4,5,6],&lt;br&gt;
[7,8,9]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;After swapping up-down we get&lt;br&gt;
[&lt;br&gt;
[7,8,9],&lt;br&gt;
[4,5,6],&lt;br&gt;
[1,2,3]&lt;br&gt;
]&lt;br&gt;
After swapping zig-zag we get&lt;br&gt;
[&lt;br&gt;
[7,4,1],&lt;br&gt;
[8,5,2],&lt;br&gt;
[9,6,3]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Swapping up-down is pretty easy and can easily be achieved by&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; matrix.length / 2; i++) {
    for (int j = 0; j &amp;lt; matrix[0].length; j++) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[matrix.length - i - 1][j];
        matrix[matrix.length - i - 1][j] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although, I had some trouble in doing zig-zag swap it required you to limit the swap. That is once we swap &lt;code&gt;matrix[0][1]&lt;/code&gt; with &lt;code&gt;matrix[1][0]&lt;/code&gt; we should not swap it again whent the value of i becomes 1 from 0. My initial approach was to limit this with a simple if check as shown below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; matrix.length; i++) {
    for (int j = 0; j &amp;lt; matrix[0].length; j++) {
        if (i &amp;lt; j) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This made my solution pass the test but it did poorly in &lt;em&gt;Accepted Solutions Runtime Distribution&lt;/em&gt;. After seeing some solutions in the &lt;em&gt;Discussion&lt;/em&gt; I found out that &lt;code&gt;j&lt;/code&gt; can start from &lt;code&gt;i+1&lt;/code&gt; since we alwasy skip swaps where &lt;code&gt;i == j&lt;/code&gt;. I thought this will improve the performance in the &lt;em&gt;Accepted Solutions Runtime Distribution&lt;/em&gt; since we are skipping one column although the time distribution was still the same.&lt;/p&gt;
&lt;p&gt;Here is my final solution&lt;/p&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p48/Solution.java"&gt;&lt;/script&gt;
&lt;h4 id="timecomplexity"&gt;Time complexity&lt;/h4&gt;
&lt;p&gt;The time complexity O(n * n) since we traverse the matrix.&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;As mentioned earlir the trick is:
&lt;ul&gt;
&lt;li&gt;Clockwise rotation: Swap up-down and then swap elements zig-zag&lt;/li&gt;
&lt;li&gt;Anticlockwise rotation: Swap left right and then swap elements zig-zag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For zig-zag conversion &lt;code&gt;j&lt;/code&gt; should start from &lt;code&gt;i + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title>28. Implement strStr()</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/implement-strstr/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem is pretty simple although I was not able to correctly solve this problem for all test cases in single attempt. The idea here is:&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/28-implement-strstr/</link><guid isPermaLink="false">59b68ab588f7011c428b15a2</guid><category>leetcode</category><dc:creator>Duct Tape Programmer</dc:creator><pubDate>Mon, 11 Sep 2017 13:18:29 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="question"&gt;&lt;a href="https://leetcode.com/problems/implement-strstr/description/"&gt;Question&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;This problem is pretty simple although I was not able to correctly solve this problem for all test cases in single attempt. The idea here is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scan through the haystack for the first character of the needle&lt;/li&gt;
&lt;li&gt;As soon as the first character is found match all the remaining character in the needlle&lt;/li&gt;
&lt;li&gt;If they do then return the index where the first character of needle occurs in the haystack.&lt;/li&gt;
&lt;li&gt;If they don't then return -1&lt;/li&gt;
&lt;li&gt;Note: For empty strings &amp;quot;&amp;quot; leetcode test cases expect to return 0. This is where my initial solution was failing as I was returning -1. I tried to have some initial checks for empty string and return early although if out of two string only one is empty then you need to return -1 and not 0.&lt;/li&gt;
&lt;/ol&gt;
&lt;script src="https://gist-it.appspot.com/github/dtprogrammer/leetcode-solutions/blob/master/src/main/java/dtprogrammer/github/io/p28/Solution.java"&gt;&lt;/script&gt;
&lt;h3 id="timecomplexity"&gt;Time complexity&lt;/h3&gt;
&lt;p&gt;Sine we scan the whole haystack for the first character of needle and then match remaining character it is very possible that in worse case we will run in O (m * n).&lt;/p&gt;
&lt;h3 id="spacecomplexity"&gt;Space complexity&lt;/h3&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;i and j together are used to index the haystack.&lt;/li&gt;
&lt;li&gt;The time complexity can be improved to O(m) where m is the size of haystack by using some intuitve algorithms like Rabin-Karp or KMP algorithms.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>